<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="xx">
    <meta name="author" content="hahahanba">
    
    <title>
        
            深入理解C++对象模型(二) |
        
        hahahanba&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="https://cdn.staticaly.com/gh/hahahanba/hahahanba.github.io@main/images/star.5dh2c651m3k0.webp">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/brands.min.css">
    
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"hahahanba.github.io","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true,"layout":"left"},"style":{"primary_color":"#0066cc","logo":"","favicon":"https://cdn.staticaly.com/gh/hahahanba/hahahanba.github.io@main/images/star.5dh2c651m3k0.webp","avatar":"https://i.imgur.com/9lnXdbm.png","first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":true},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":true,"preload":true},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":true},"comment":{"enable":true,"use":"giscus","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":"hahahanba/comments","repo_id":"R_kgDOKGpC9g","category":"Announcements","category_id":"DIC_kwDOKGpC9s4CYk-p","reactions_enabled":true}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect","emmm..."]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":true,"img_align":"left"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"version":"3.7.3"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
            <a class="site-name border-box" href="/">
               hahahanba&#39;s Blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">

                

                    <div class="fade-in-down-animation">
    <div class="post-page-container border-box">

        <div class="article-content-container border-box">

            <div class="article-title">
                <span class="title-hover-animation">深入理解C++对象模型(二)</span>
            </div>

            
                <div class="article-header border-box">
                    
                        <div class="avatar-box border-box">
                            <img src="https://i.imgur.com/9lnXdbm.png">
                        </div>
                    
                    <div class="info-box">
                        <div class="author">
                            <span class="name">hahahanba</span>
                            
                                <span class="author-label">Lv1</span>
                            
                        </div>
                        <div class="meta-info border-box">
                            

<div class="article-meta-info-container border-box post">
    <div class="article-meta-info border-box">
        


        
            <span class="meta-info-item article-create-date">
                <i class="icon fa-solid fa-calendar-check"></i>&nbsp;
                <span class="pc">2024-04-18 10:42:13</span>
                <span class="mobile">2024-04-18 10:42</span>
            </span>

            <span class="meta-info-item article-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="pc">2024-04-18 10:50:32</span>
            </span>
        

        
            <span class="meta-info-item article-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul>
                    
                            <li class="category-item">
                                
                                <a href="/categories/C/">C++</a>
                            </li>
                        
                    
                </ul>
            </span>
        

        
            <span class="article-tag meta-info-item border-box">
                <i class="icon fas fa-tags"></i>&nbsp;
                <ul>
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">深入理解对象模型</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item article-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>4.6k 字</span>
            </span>
        
        
            <span class="meta-info-item article-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>17 分钟</span>
            </span>
        
        
            <span class="meta-info-item article-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h1 id="构造函数语义学"><a href="#构造函数语义学" class="headerlink" title="构造函数语义学"></a>构造函数语义学</h1><h2 id="一、默认构造函数的构造操作"><a href="#一、默认构造函数的构造操作" class="headerlink" title="一、默认构造函数的构造操作"></a>一、默认构造函数的构造操作</h2><p>C++中对于默认构造函数的解释是：<strong>默认的构造函数会在需要的时候被编译器产生出来</strong>。如下述实例所示，正确的程序语意要求<code>Foo</code>有一个默认构造函数，可以将它的两个成员初始化为0。那上述实例会合成出一个默认构造函数吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Foo *pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Foo bar;</span><br><span class="line">  <span class="keyword">if</span> (bar.val || bar.pnext)</span><br><span class="line">    <span class="comment">// ... do sth</span></span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实并不会！默认构造函数的合成关键是在于谁需要？是程序的需要还是编译器的需要？如果是程序的需要，那初始化便是程序员的责任。而上述例子便是程序员的责任，因此程序并不会合成一个默认构造函数。那么，什么时候编译器才会合成一个默认构造函数呢？ </p>
<ul>
<li><strong>当编译器需要默认构造函数的时候才会合成出一个默认构造函数!</strong> 且被合成出来的构造函数只执行编译器所需的行动。这样合成的默认构造函数是<code>notrivial</code>的，并且这个产生操作只有在默认构造函数真正被调用时才会进行合成。</li>
<li>如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是<code>trivial</code>的。<strong>需要注意<code>trivial</code>构造函数只存在于概念上，编译器实际上根本不会去合成出来</strong>（此类构造函数不做任何有意义的事情，所以编译器不去合成它）。</li>
</ul>
<h3 id="1-1-什么时候下会合成默认构造函数？"><a href="#1-1-什么时候下会合成默认构造函数？" class="headerlink" title="1.1 什么时候下会合成默认构造函数？"></a>1.1 什么时候下会合成默认构造函数？</h3><p>通常编译器会在以下四种情况会合成<code>notrivial</code>的默认构造函数。</p>
<h4 id="1-1-1-具有默认构造函数的成员类对象"><a href="#1-1-1-具有默认构造函数的成员类对象" class="headerlink" title="1.1.1 具有默认构造函数的成员类对象"></a>1.1.1 <strong>具有默认构造函数的成员类对象</strong></h4><ul>
<li>类没有任何构造函数，但它内含一个含有默认构造函数的成员类，那么这个类的<code>implicit</code>默认构造函数就是<code>nontrivial</code>， 编译器需要为该类合成出 一个默认构造函数。</li>
</ul>
<p>考虑下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; <span class="keyword">public</span>: <span class="built_in">Foo</span>(), <span class="built_in">Foo</span>(<span class="type">int</span>) ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; <span class="keyword">public</span>: Foo foo; <span class="type">char</span> *str; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Bar bar; <span class="comment">// Bar::foo must be initialized here</span></span><br><span class="line">  <span class="keyword">if</span> (str) &#123;&#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被合成的<code>Bar</code>默认构造函数内含必要的代码，使其能够调用类 <code>Foo</code> 的默认构造函数来处理成员对象 <code>Bar::bar</code>，但它并不产生任何代码来初始化Bar::str。被合成的默认构造函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Bar::bar</span><span class="params">()</span> </span>&#123; foo.Foo::<span class="built_in">Foo</span>();&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个有趣的问题：类声明头文件可以被许多源文件所包含，如何避免合成默认构造函数、拷贝构造函数、析构函数、 赋值拷贝操作符(4 大成员函数)时不引起函数的重定义?<br>解决方法是以 inline 的方式完成（一个inline函数有静态链接，不会被文件以外者看到），如果函数太复杂不适合 inline，就会合成一个 explicit non-inline static 实例 (Static 函数独立于编译单元)</p>
</blockquote>
<ul>
<li>如果类 <code>A</code> 内含一个或一个以上的成员类对象，那么类 <code>A</code> 的每一个构造函数必须调用每一个成员类的默认构造函数。<code>C++</code> 要求以成员对象在类中的声明顺序来调用各个构造函数。这一点由编译器完成，它为每一个构造函数安插程序代码，以“成员声明顺序”调用每一个成员所关联的默认构造函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dopey</span> &#123; <span class="keyword">public</span>: Dopey; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneezy</span> &#123; <span class="keyword">public</span>: <span class="built_in">Sneezy</span>(<span class="type">int</span>); <span class="built_in">Sneezy</span>(); ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bashful</span> &#123; <span class="keyword">public</span>: <span class="built_in">Bashful</span>(); ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snow_White</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Dopey dopey;</span><br><span class="line">  Sneezy sneezy;</span><br><span class="line">  Bashful bashful;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> mumble;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Snow_White未定义默认构造函数，就会有一个nontrivial构造函数</span></span><br><span class="line"><span class="comment">// 被合成出来，依次调用Dopey、Sneezy、Bashful的默认构造函数。</span></span><br><span class="line">Snow_White::<span class="built_in">Snow_white</span>()</span><br><span class="line">&#123;</span><br><span class="line">  dopey.Dopey::<span class="built_in">Dopey</span>();</span><br><span class="line">  sneezy.Sneezy::<span class="built_in">Sneezy</span>();</span><br><span class="line">  bashful.Bashful::<span class="built_in">Bashful</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果Snow_White定义了默认构造函数，就会有下述nontrivial构造函数被合成出来。</span></span><br><span class="line"><span class="comment">// 已定义构造函数</span></span><br><span class="line">Snow_White::<span class="built_in">Snow_white</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123; </span><br><span class="line">  mumble = <span class="number">2048</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码扩张后</span></span><br><span class="line">Snow_White::<span class="built_in">Snow_white</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">  dopey.Dopey::<span class="built_in">Dopey</span>();</span><br><span class="line">  sneezy.Sneezy::<span class="built_in">Sneezy</span>(<span class="number">1024</span>);</span><br><span class="line">  bashful.Bashful::<span class="built_in">Bashful</span>();</span><br><span class="line">  </span><br><span class="line">  mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-带有默认构造函数的基类"><a href="#1-1-2-带有默认构造函数的基类" class="headerlink" title="1.1.2 带有默认构造函数的基类"></a>1.1.2 带有默认构造函数的基类</h4><p>如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，那么这个派生类的默认构造函数会被视为 <code>nontrivial</code> ，并且这个默认构造函数会被按照基类的声明顺序调用基类的默认构造函数合成出来。</p>
<p>如果设计者提供多个构造函数，但其中都没有默认构造函数的话，<strong>编译器会扩张现有的每一个构造函数</strong>，将用以调用所有必要的默认构造函数的程序代码加进去。(它不会合成 一个新的默认构造函数)。</p>
<h4 id="1-1-3-带有虚函数的类"><a href="#1-1-3-带有虚函数的类" class="headerlink" title="1.1.3 带有虚函数的类"></a>1.1.3 带有虚函数的类</h4><p>有两种情况需要合成出默认构造函数：</p>
<ul>
<li>类声明(或继承)一个虚函数。</li>
<li>类派生自一个继承串链，其中有一个或者更多的虚基类。</li>
</ul>
<p>不管哪一种情况，由于缺乏用户声明的构造函数，编译器会详细记录合成一个默认构造函数的必要信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span> </span>&#123; widget.<span class="built_in">flip</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设Bell和Whistle都派生自Widget</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Bell b;</span><br><span class="line">  Whistle w;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">flip</span>(b);</span><br><span class="line">  <span class="built_in">flip</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于含有虚函数，其扩张行动会发生在编译期间：</p>
<ul>
<li>编译器会产生一个虚表vtbl，其内放置类的虚函数地址。</li>
<li>每一个类对象中，编译器会额外的合成一个指针成员vptr指向与之相关的类虚表vtbl。</li>
</ul>
<p>此外，widget.flip()的虚拟调用操作(virtual invocation)会被重新改写，以使用 widget 的 vptr 和 vtbl 中的 flip 条目：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// widget.flip()的虚拟调用操作(virtual invocation)</span></span><br><span class="line">(*widget.vptr[<span class="number">1</span>])(&amp;widget)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1表示flip()在 virtual table 中的固定索引;</span></span><br><span class="line"><span class="comment">// &amp;widget 代表要交给被调用的某个flip()实例的this指针</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了让这个机制生效，编译器必须为每一个Widget(或其派生类) 对象的 vptr 设定初值，放置适当的virtual table地址。</p>
</blockquote>
<h4 id="1-1-4-带有虚基类的类"><a href="#1-1-4-带有虚基类的类" class="headerlink" title="1.1.4 带有虚基类的类"></a>1.1.4 带有虚基类的类</h4><p>虚基类的实现法在不同的编译器之间有极大的差异。然而，每一种<br>实现法的共同点在于必须使虚基类在其每一个派生类对象中的位置，能够于执行期准备妥当。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; <span class="keyword">public</span>: <span class="type">int</span> j; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; <span class="keyword">public</span>: <span class="type">double</span> d; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; <span class="keyword">public</span>: <span class="type">int</span> k; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译期决定pa-&gt;X::i的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">  <span class="built_in">foo</span>(<span class="keyword">new</span> C);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能的编译器转变操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span> </span>&#123; pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>编译器无法固定住 <code>foo()</code> 之中“经由 <code>pa</code> 而存取的 <code>X::i</code> 的实际偏移位置，因为 <code>pa</code> 的真正类型可以改变。编译器必须改变执行存取操作的那些代码，使 <code>X::i</code> 可以延迟至执行期才决定下来。</p>
<p> __ vbcX (或编译器所做出的某个什么东西) 是在类对象构造期间被完成的。对于类所定义的每一个构造函数，编译器会安插那些 “允许每一个虚基类的执行期存取操作” 的代码。如果类没有声明任何构造函数，编译器必须为它合成一个默认的构造函数。</p>
<p>被合成出来的构造函数只能满足编译器的需要，通过下属两种方法：</p>
<ul>
<li>通过调用成员对象或基类的默认构造函数；</li>
<li>为每一个对象初始化其虚函数机制或虚基类机制。</li>
</ul>
<p><strong>C++新手常见的2个误区:</strong></p>
<ul>
<li><p><font color=red><strong>ERROR:</strong></font> 如果类没有定义默认构造函数就会被合成一个。首先定义了其它的构造函数就不会合成默认构造函数；再次即使没有定义任何构造函数也不一定会合成默认构造函数，可能仅仅是概念上有，但实际上不合成出来。</p>
</li>
<li><p><font color=red><strong>ERROR:</strong></font>  编译器合成出来的默认构造函数会显式设定类内每一个数据成员的默认值。明显不会，区分了全局对象，栈对象、堆对象 就非常明白了只有在全局上的对象会被清 0，其它的情况都不会保证被清 0。</p>
</li>
</ul>
<h2 id="二、拷贝构造函数的构造操作"><a href="#二、拷贝构造函数的构造操作" class="headerlink" title="二、拷贝构造函数的构造操作"></a>二、拷贝构造函数的构造操作</h2><p>拷贝构造函数和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的类来说，拷贝构造函数仅仅需要按位拷贝就可以。当然，满足 <code>bitwise copy semantics</code> 的拷贝构造函数是 <code>trivial</code> 的，不会真正被合成出来，与默认构造函数一样，只有 <code>nontrivial</code> 的拷贝构造函数才会被真正合成出来。</p>
<h4 id="2-1-什么时候一个类不展现bitwise-copy-semantics呢？"><a href="#2-1-什么时候一个类不展现bitwise-copy-semantics呢？" class="headerlink" title="2.1 什么时候一个类不展现bitwise copy semantics呢？"></a>2.1 什么时候一个类不展现bitwise copy semantics呢？</h4><p>分为四种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。</p>
<ol>
<li>当类内含一个成员对象而后者声明了(也可能由于 <code>nontrivial</code> 语意从而编译器真正合成出来的)一个拷贝构造函数时。</li>
<li>当类继承自一个基类，而后者存在一个拷贝构造函数时(不论是被显式声明或是被合成而得)。</li>
<li>当类声明了一个或多个虚函数时。</li>
<li>当类派生自一个继承串链，其中有一个或多个虚基类时。</li>
</ol>
<h5 id="2-1-1-重新设定虚表的指针"><a href="#2-1-1-重新设定虚表的指针" class="headerlink" title="2.1.1 重新设定虚表的指针"></a>2.1.1 重新设定虚表的指针</h5><p>对于每一个新产生的类对象，如果编译器不能成功而正确的设置好其 <code>vptr</code> 的初值，将会导致可怕的后果。因此当编译器导入一个 <code>vptr</code> 到类中时，该类就不再展现 <code>bitwise</code> 语意了。</p>
<p>考虑下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ZooAnimal</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ZooAnimal的animate()和draw()</span></span><br><span class="line">  <span class="comment">// 所需要的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Bear</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>; <span class="comment">// 虽未明写virtual，但它其实是virtual</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;    <span class="comment">// 虽未明写virtual，但它其实是virtual</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Bear的animate()、dance()和draw()</span></span><br><span class="line">  <span class="comment">// 所需要的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ZooAnimal</code> 类对象以另一个 <code>ZooAnimal</code> 类对象作为初值，或 <code>Bear</code> 类对象以另一个 <code>Bear</code> 类对象作为初值，都可以直接靠 <code>bitwise copy semantics</code> 完成。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bear yogi;</span><br><span class="line">Bear winnie = yogi;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic.imgdb.cn/item/662088550ea9cb1403aed05c.png"
                      alt="bitwise copy semantics"
                ></p>
<p><code>yogi</code> 会被默认的 <code>Bear</code> 构造函数初始化。<code>yogi</code> 的 <code>vptr</code> 被设定指向 <code>Bear</code> 的虚表。因此，把<code>yogi</code> 的 <code>vptr</code> 值拷贝给 <code>winnie</code> 的 <code>vptr</code> 是安全的。</p>
<ul>
<li>类对象以其派生类的对象内容做初始化操作时，其 <code>vptr</code> 复制操作也必须保证安全。<code>franny</code> 的 <code>vptr</code> 不可以被设定指向 <code>Bear</code> 的虚表。否则当下面程序片段中的 <code>draw()</code> 被调用而<code>franny</code> 被传进去时，就会出问题：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bear yogi;</span><br><span class="line">ZooAnimal franny = yogi; <span class="comment">// 注意此处会发生切割行为</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">const</span> ZooAnimal&amp; zoey)</span> </span>&#123; zoey.<span class="built_in">draw</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// franny的vptr指向ZooAnimal的虚表而非Bear的虚表</span></span><br><span class="line">  ZooAnimal franny = yogi;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">draw</span>(yogi);   <span class="comment">// 调用Bear::draw()</span></span><br><span class="line">  <span class="built_in">draw</span>(franny); <span class="comment">// 调用ZooAnimal::draw()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic.imgdb.cn/item/6620895f0ea9cb1403b54944.png"
                      alt="non-bitwise copy semantices"
                ></p>
<p>也就是说，合成出来的<code>ZooAnimal</code> 拷贝构造函数会显式设定对象的 <code>vptr</code> 指向 <code>ZooAnimal</code>  类的虚表而不是直接从右手边的类对象中将其 <code>vptr</code> 现值拷贝过来。</p>
<h5 id="2-1-2-虚基类子对象"><a href="#2-1-2-虚基类子对象" class="headerlink" title="2.1.2 虚基类子对象"></a>2.1.2 虚基类子对象</h5><p>虚基类的存在需要特别处理。一个类对象如果以另一个对象作为初值，而后者有一个虚基类子对象，那么也会使 <code>bitwise copy semantics</code> 失效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Raccoon</span>() &#123;<span class="comment">/*设定私有数据初值*/</span>&#125;</span><br><span class="line">  <span class="built_in">Raccoon</span>( <span class="type">int</span> val ) &#123;<span class="comment">/*设定私有数据初值*/</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 所有必要的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedPanda</span> : <span class="keyword">public</span> Raccoon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RedPanda</span>() &#123;<span class="comment">/*设定私有数据初值*/</span>&#125;</span><br><span class="line">  <span class="built_in">RedPanda</span>( <span class="type">int</span> val ) &#123;<span class="comment">/*设定私有数据初值*/</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 所有必要的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的bitwise copy还不够，编译器必须显式地将</span></span><br><span class="line"><span class="comment">// little_critter的虚基类pointer/offset初始化</span></span><br><span class="line">RedPanda little_red;</span><br><span class="line">Raccoon little_critter = little_red;</span><br></pre></td></tr></table></figure>

<p>在上述情况下，为了完成正确的 <code>little_red</code> 初值设定，编译器必须合成一个拷贝构造函数，安插一些代码以设定虚基类pointer&#x2F;offset 初值，对每一个成员执行必要的 <code>memberwise</code>初始化操作，以及执行其他的内存相关工作。</p>
<p>在下面的情况，编译器无法知道 <code>bitwise copy semantics</code> 是否还保持着，因为它无法知道 <code>Raccoon</code> 指针是否指向一个真正的 <code>Raccoon</code> 对象或者指向一个派生类对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Raccoon *ptr;</span><br><span class="line">Raccoon little_critter = *ptr;</span><br></pre></td></tr></table></figure>

<h2 id="三、程序转化语义学"><a href="#三、程序转化语义学" class="headerlink" title="三、程序转化语义学"></a>三、程序转化语义学</h2><p>本部分是讨论编译器调用拷贝构造函数时的策略(如何优化以提高效率)，或者说是是关于编译器对于程序是如何进行有效转化或者说翻译，以实现C++的语法机制。主要有以下的几种语意：</p>
<h4 id="3-1-显式初始化操作"><a href="#3-1-显式初始化操作" class="headerlink" title="3.1 显式初始化操作"></a>3.1 显式初始化操作</h4><p>可以考虑如下的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">X x0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;</span><br><span class="line">  X x2 = x0;</span><br><span class="line">  X x3 = <span class="built_in">X</span>(x0);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必要的程序转化需要两个阶段：</span></span><br><span class="line"><span class="comment">// 1. 重写每一个定义，但不会执行初始化操作。</span></span><br><span class="line"><span class="comment">// 2. 安插类的拷贝构造函数调用操作。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;</span><br><span class="line">  X x2 = x0;</span><br><span class="line">  X x3 = <span class="built_in">X</span>(x0);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 编译器安插X的拷贝构造函数的调用操作</span></span><br><span class="line">  x1.X::<span class="built_in">X</span>(x0);</span><br><span class="line">  x2.X::<span class="built_in">X</span>(x0);</span><br><span class="line">  x3.X::<span class="built_in">X</span>(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-参数的初始化"><a href="#3-2-参数的初始化" class="headerlink" title="3.2 参数的初始化"></a>3.2 参数的初始化</h4><p>C++标准(8.5节)说，把一个类对象当做参数传递给一个函数或者把它作为一个函数的返回值时，相当于以下形式的初始化操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中xx是形式参数或者返回值，arg代表真正的参数值。</span></span><br><span class="line">X xx = arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若已知下面的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X x0)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若采用下述的调用方式，将会使得局部实例x0以 memberwise 的形式以实际参数为初始值进行初始化</span></span><br><span class="line">X xx;</span><br><span class="line"><span class="built_in">foo</span>(xx);</span><br></pre></td></tr></table></figure>

<p>一般来说，编译器有两种做法：</p>
<ul>
<li>引入一个临时性对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 编译器生成一个临时性对象</span></span><br><span class="line">X __temp0;</span><br><span class="line"><span class="comment">// 2. 编译器对拷贝构造函数的调用</span></span><br><span class="line">__temp0.X::<span class="built_in">X</span>(xx);</span><br><span class="line"><span class="comment">// 3. 重新改写函数调用操作;</span></span><br><span class="line"><span class="built_in">foo</span>(__temp0);</span><br><span class="line"><span class="comment">// 4. 修改参数调用方式为引用，否则如何工作又回到原点啦(临时性对象以类X的拷贝构造函数正确的设定初值，然后以bitwise的方式拷贝到x0这个局部实例中)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X &amp;x0)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>采用“拷贝构建”的方式，将参数直接以拷贝构造函数建构到函数的堆栈上。</li>
</ul>
<h4 id="3-3-返回值的初始化"><a href="#3-3-返回值的初始化" class="headerlink" title="3.3 返回值的初始化"></a>3.3 返回值的初始化</h4><p>当返回值是对象时，这个对象是如何返回的呢？<code>cfront</code> 使用的是一个双阶段转化：</p>
<ul>
<li>首先加上一个额外的参数，是类对象的引用，这个参数将放置通过拷贝构建得来的返回值。</li>
<li>在<code>return</code> 之前安插一个拷贝构建函数的调用操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X xx;</span><br><span class="line">  <span class="comment">// 处理xx ...</span></span><br><span class="line">  <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar()转换</span></span><br><span class="line"><span class="comment">//安插了临时引用参数__result</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(X &amp; __result)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X xx;</span><br><span class="line">  <span class="comment">// 默认构造函数调用</span></span><br><span class="line">  xx.X::<span class="built_in">X</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理xx...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 拷贝构造函数调用操作</span></span><br><span class="line">  __result.X::<span class="built_in">X</span>(xx);  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、成员初始化列表"><a href="#四、成员初始化列表" class="headerlink" title="四、成员初始化列表"></a>四、成员初始化列表</h2><p>当我们写下一个构造函数时，就有机会设定类成员的初值。要不是由成员初始化列表，就是在构造函数函数体之内。除了4种情况，你的任何选择其实都差不多。</p>
<h4 id="4-1-初始化列表内部的真正操作是什么？"><a href="#4-1-初始化列表内部的真正操作是什么？" class="headerlink" title="4.1 初始化列表内部的真正操作是什么？"></a>4.1 初始化列表内部的真正操作是什么？</h4><p>为了让你的程序能够顺利被编译，你必须使用成员列表初始化：</p>
<ul>
<li>当初始化一个 <code>reference member</code> 时；</li>
<li>当初始化一个 <code> const member</code> 时；</li>
<li>当调用一个基类的构造函数，而它拥有一组参数时；</li>
<li>当调用一个成员类的构造函数，而它拥有一组参数时；</li>
</ul>
<p>在这4种情况下，程序可以被正确编译并执行，但是效率不高。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span> &#123;</span><br><span class="line">  String _name;</span><br><span class="line">  <span class="type">int</span>    _cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Word</span>() &#123;</span><br><span class="line">    _name = <span class="number">0</span>;</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里 Word 构造函数会产生一个临时性的 String 对象，然后将它初始化，之后以一个赋值运算符将临时性的对象指定给 _name，随后再摧毁那个临时性的对象。</span></span><br><span class="line"><span class="comment">// 构造函数内部扩张结果</span></span><br><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line">Word::<span class="built_in">Word</span>(<span class="comment">/* this pointer goes here*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 调用 String 的默认构造函数</span></span><br><span class="line">  _name.String::<span class="built_in">String</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 产生临时性对象</span></span><br><span class="line">  String temp = <span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// memberwise 地拷贝 _name</span></span><br><span class="line">  _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 摧毁临时性对象</span></span><br><span class="line">  temp.String::~<span class="built_in">String</span>();</span><br><span class="line">  </span><br><span class="line">  _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更明显有效率的实现方法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 较佳的方式</span></span><br><span class="line">Word::Word : _name(<span class="number">0</span>) &#123; _cnt = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩张后</span></span><br><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line">Word::<span class="built_in">Word</span>(<span class="comment">/* this pointer goes here*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 调用 String(int) 构造函数</span></span><br><span class="line">  _name.String::<span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">  _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-成员列表初始化中会发生什么？"><a href="#4-1-1-成员列表初始化中会发生什么？" class="headerlink" title="4.1.1 成员列表初始化中会发生什么？"></a>4.1.1 成员列表初始化中会发生什么？</h4><p>编译器会一一操作列表初始化，以适当顺序在构造函数之内安插初始化操作，并且在任何显式用户代码之前。<strong>且需要注意：列表中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表中的排列顺序决定的。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于声明顺序的缘故，成员列表初始化中的 i(j) 其实比 j(val) 更早执行。但因为j一开始未有初值，所以i(j)的执行结果导致i无法预知其值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val), <span class="built_in">i</span>(j) &#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较受到喜爱的方式</span></span><br><span class="line">X::<span class="built_in">X</span>(<span class="type">int</span> val)</span><br><span class="line">  :<span class="built_in">j</span>(val)</span><br><span class="line">&#123; i = j; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外一个常见的问题是，调用一个成员函数设定一个成员的初值</span></span><br><span class="line"><span class="comment">// X::xfoo()被调用，这样好吗？</span></span><br><span class="line">X::<span class="built_in">X</span>(<span class="type">int</span> val)</span><br><span class="line">  : <span class="built_in">i</span>(<span class="built_in">xfoo</span>(val)), <span class="built_in">j</span>(val)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 你并不知道xfoo()对X对象的依赖性有多高，如果xfoo()放到构造函数体内，那么对于“到底是哪一个成员在xfoo()执行时被设立初值”这件事，就可以确保不会发生模棱两可的情况。</span></span><br></pre></td></tr></table></figure>


            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">深入理解C++对象模型(二)</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">hahahanba</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2024-04-18 10:42:13</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2024/04/18/深入理解C-对象模型-二/</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"><i class="icon fas fa-hashtag"></i>深入理解对象模型</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2024/04/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item text-ellipsis">深入理解C++对象模型(一)</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
                


    <div class="comments-container">
        <div id="comments-anchor"></div>
        <div class="comment-area-title">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        
            

    <div class="giscus-comments-container">
        <div class="giscus" id="giscus"></div>
        <script >

          if (!window?.__getGiscusTheme) {
            window.__getGiscusTheme = () => {
              return document.body.classList.contains("dark-mode") ? "dark_dimmed" : "light_tritanopia";
            };
          }

          if (!window?.__changeGiscusTheme) {
            window.__changeGiscusTheme = () => {
              const iframe = document.querySelector("iframe.giscus-frame");
              iframe && iframe.contentWindow.postMessage({
                giscus: {
                  setConfig: {
                    theme: __getGiscusTheme()
                  }
                }
              }, "https://giscus.app");
            };
          }

          if (!window?.__loadGiscus) {
            window.__loadGiscus = () => {
              const script = document.createElement("script");
              script.async = true;
              script.src = "https://giscus.app/client.js";
              script.setAttribute("data-repo", 'hahahanba/comments');
              script.setAttribute("data-repo-id", 'R_kgDOKGpC9g');
              script.setAttribute("data-category", 'Announcements');
              script.setAttribute("data-category-id", 'DIC_kwDOKGpC9s4CYk-p');
              script.setAttribute("data-reactions-enabled", '1');
              script.setAttribute("data-lang", 'zh-CN');
              script.setAttribute("data-mapping", "pathname");
              script.setAttribute("data-strict", "0");
              script.setAttribute("data-emit-metadata", "0");
              script.setAttribute("data-input-position", "top");
              script.setAttribute("crossorigin", "anonymous");
              script.setAttribute("loading", "lazy");
              script.setAttribute("data-theme", __getGiscusTheme());
              document.querySelector(".giscus-comments-container").appendChild(script);

              const toggleThemeBtn = document.querySelector(".tool-dark-light-toggle");
              toggleThemeBtn && toggleThemeBtn.addEventListener("click", () => {
                __changeGiscusTheme();
              });
            }
          }

          if ('false' === "true") {
            setTimeout(() => {
              __loadGiscus();
            }, 1000);
          } else {
            window.addEventListener("DOMContentLoaded", () => {
              setTimeout(() => {
                __loadGiscus();
              }, 1000);
            });
          }
        </script>
    </div>


        
    </div>





            
        </div>

        
            <div class="pc-post-toc left-toc">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="nav-number">1.</span> <span class="nav-text">构造函数语义学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">一、默认构造函数的构造操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8B%E4%BC%9A%E5%90%88%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 什么时候下会合成默认构造函数？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%85%B7%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%88%90%E5%91%98%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.1.1 具有默认构造函数的成员类对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1.1.2 带有默认构造函数的基类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E5%B8%A6%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">1.1.3 带有虚函数的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E5%B8%A6%E6%9C%89%E8%99%9A%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%B1%BB"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">1.1.4 带有虚基类的类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">二、拷贝构造函数的构造操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E5%B1%95%E7%8E%B0bitwise-copy-semantics%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">2.1 什么时候一个类不展现bitwise copy semantics呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-%E9%87%8D%E6%96%B0%E8%AE%BE%E5%AE%9A%E8%99%9A%E8%A1%A8%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">1.2.0.1.1.</span> <span class="nav-text">2.1.1 重新设定虚表的指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-%E8%99%9A%E5%9F%BA%E7%B1%BB%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.0.1.2.</span> <span class="nav-text">2.1.2 虚基类子对象</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8C%96%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="nav-number">1.3.</span> <span class="nav-text">三、程序转化语义学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">3.1 显式初始化操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">3.2 参数的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">3.3 返回值的初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">四、成员初始化列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%86%85%E9%83%A8%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%93%8D%E4%BD%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">4.1 初始化列表内部的真正操作是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">4.1.1 成员列表初始化中会发生什么？</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2023</span>&nbsp;-&nbsp;2024
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">hahahanba</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.7.3</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            
                <span class="count-box border-box word">
                    <span class="item-type border-box">全站总字数</span>
                    <span class="item-value border-box word">18.9k</span>
                </span>
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访问人数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">总访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools left-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="nav-number">1.</span> <span class="nav-text">构造函数语义学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">一、默认构造函数的构造操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8B%E4%BC%9A%E5%90%88%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 什么时候下会合成默认构造函数？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%85%B7%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%88%90%E5%91%98%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.1.1 具有默认构造函数的成员类对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1.1.2 带有默认构造函数的基类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E5%B8%A6%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">1.1.3 带有虚函数的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E5%B8%A6%E6%9C%89%E8%99%9A%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%B1%BB"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">1.1.4 带有虚基类的类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">二、拷贝构造函数的构造操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E5%B1%95%E7%8E%B0bitwise-copy-semantics%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">2.1 什么时候一个类不展现bitwise copy semantics呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-%E9%87%8D%E6%96%B0%E8%AE%BE%E5%AE%9A%E8%99%9A%E8%A1%A8%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">1.2.0.1.1.</span> <span class="nav-text">2.1.1 重新设定虚表的指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-%E8%99%9A%E5%9F%BA%E7%B1%BB%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.0.1.2.</span> <span class="nav-text">2.1.2 虚基类子对象</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8C%96%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="nav-number">1.3.</span> <span class="nav-text">三、程序转化语义学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">3.1 显式初始化操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">3.2 参数的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">3.3 返回值的初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">四、成员初始化列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%86%85%E9%83%A8%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%93%8D%E4%BD%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">4.1 初始化列表内部的真正操作是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">4.1.1 成员列表初始化中会发生什么？</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/toc.js"></script>
        
    
    
    
</div>




</body>
</html>
