<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/08/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2023/08/17/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>test1</title>
    <url>/2023/08/18/test1/</url>
    <content><![CDATA[<p> for deployment test</p>
]]></content>
  </entry>
  <entry>
    <title>编译和链接</title>
    <url>/2023/09/08/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>对于平常的应用程序开发，我们很少需要关注编译与链接过程。因为通常的开发环境都是流行的集成开发环境（IDE），比如Visual Studio等。这样的IDE一般都将编译和链接的过程一步完成，通常这种编译和链接合并到一起的过程为构建（Build）。但是在这样的开发过程中，我们往往会被这些复杂的集成工具所提供的强大功能所迷惑，很多系统软件的运行机制与机理被掩盖，其程序的很多莫名其妙的错误让我们无所适从，面对程序运行时种种性能瓶颈我们束手无策。如果能够深入了解这些机制，那么解决这些问题就能够游刃有余，收放自如了。</p>
<h1 id="被隐藏的过程"><a href="#被隐藏的过程" class="headerlink" title="被隐藏的过程"></a>被隐藏的过程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux下，当我们使用GCC来编译Hello World程序时，只需要最简单的命令我们便可以在屏幕上打印出“Hello World”字样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>事实上，上述过程可以分解为以下四个过程：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.staticaly.com/gh/hahahanba/hahahanba.github.io@main/images/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%88%86%E8%A7%A3.67oi1tq9bps0.webp"
                      alt="GCC编译过程分解"
                ></p>
<ul>
<li>预处理(Prepressing)</li>
<li>编译(Compilation)</li>
<li>汇编(Assembly)</li>
<li>链接(Linking)</li>
</ul>
<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预编译过程主要处理那些源代码文件中以“#”开始的预编译指令。比如<code>#include</code>、<code>#define</code>等，主要的处理规则如下：</p>
<ul>
<li>将所有的<code>#define</code>删除，并且展开所有的宏定义。</li>
<li>处理所有条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>。</li>
<li>处理<code>#include</code>预编译指令，将被包涵的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他的文件。</li>
<li>删除所有的注释<code>//</code>和<code>/**/</code>。</li>
<li>添加行号和文件名标识，比如<code>#2 hello.c 2</code>，以便编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的<code>#pragma</code>编译器指令，因为编译器要使用它们。</li>
</ul>
<p>我们可是使用如下的命令，将源代码文件<code>hello.c</code>和相关的头文件如<code>stdio.h</code>等被预编译器<code>cpp</code>预编译成一个<code>.i</code>文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i</span><br><span class="line">或者</span><br><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure>

<p>其<code>hello.i</code>文件如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">1</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">3</span></span><br><span class="line"># <span class="number">384</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">3</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command line&gt;&quot;</span> <span class="number">1</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">__uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">__int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">__uint16_t</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __vsnprintf_chk (<span class="type">char</span> * <span class="keyword">restrict</span>, <span class="type">size_t</span>, <span class="type">int</span>, <span class="type">size_t</span>,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span>, va_list);</span><br><span class="line"># <span class="number">417</span> <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">5</span> <span class="string">&quot;hello.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译过程就是把预处理完成的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。上面的编译过程相当于如下的命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.s</span><br><span class="line">或者</span><br><span class="line">$ gcc -S hello.c -o hello.s   <span class="comment">// 将预编译和编译合并</span></span><br></pre></td></tr></table></figure>

<p>汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.section	__TEXT,__text,regular,pure_instructions</span><br><span class="line">	.build_version macos, 13, 0	sdk_version 13, 3</span><br><span class="line">	.globl	_main                           ## -- Begin function main</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">_main:                                  ## @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line">## %bb.0:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movl	$0, -4(%rbp)</span><br><span class="line">	leaq	L_.str(%rip), %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_printf</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	addq	$16, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        ## -- End function</span><br><span class="line">	.section	__TEXT,__cstring,cstring_literals</span><br><span class="line">L_.str:                                 ## @.str</span><br><span class="line">	.asciz	&quot;Hello World\n&quot;</span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>

<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。上述汇编过程我们可以用一下命令完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ as hello.s -o hello.o.  <span class="comment">// as是汇编器</span></span><br><span class="line">或者</span><br><span class="line">$ gcc -c hello.s -o hello.o  </span><br><span class="line">或者</span><br><span class="line">$ gcc -c hello.c -o hello.o   <span class="comment">// 经过预编译、编译和汇编直接输出目标文件（Object File）</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>objdump -d hello.o </code>命令来查看 <code>.o</code>文件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.o:        file format mach-o 64-bit x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section __TEXT,__text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;_main&gt;:</span><br><span class="line">       0: 55                            pushq   %rbp</span><br><span class="line">       1: 48 89 e5                      movq    %rsp, %rbp</span><br><span class="line">       4: 48 83 ec 10                   subq    $16, %rsp</span><br><span class="line">       8: c7 45 fc 00 00 00 00          movl    $0, -4(%rbp)</span><br><span class="line">       f: 48 8d 3d 0f 00 00 00          leaq    15(%rip), %rdi          ## 0x25 &lt;_main+0x25&gt;</span><br><span class="line">      16: b0 00                         movb    $0, %al</span><br><span class="line">      18: e8 00 00 00 00                callq   0x1d &lt;_main+0x1d&gt;</span><br><span class="line">      1d: 31 c0                         xorl    %eax, %eax</span><br><span class="line">      1f: 48 83 c4 10                   addq    $16, %rsp</span><br><span class="line">      23: 5d                            popq    %rbp</span><br><span class="line">      24: c3                            retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>通常我们要将一大堆文件链接起来才可以得到<code>a.out</code>文件，即最终的可执行文件。我们可以通过以下命令来获取所有的编译选项：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc hello.c --verbose <span class="comment">// 或 gcc -v hello.c</span></span><br></pre></td></tr></table></figure>

<p>输出的编译信息含义可参考<a class="link"   href="https://stackoverflow.com/questions/13440549/gcc-verbose-mode-output-explanation" >gcc-verbose<i class="fas fa-external-link-alt"></i></a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>程序员的自我修养-链接，装载与库</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>链接，装载与库</tag>
      </tags>
  </entry>
</search>
