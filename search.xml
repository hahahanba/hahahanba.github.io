<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编译和链接</title>
    <url>/2023/09/08/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>对于平常的应用程序开发，我们很少需要关注编译与链接过程。因为通常的开发环境都是流行的集成开发环境（IDE），比如Visual Studio等。这样的IDE一般都将编译和链接的过程一步完成，通常这种编译和链接合并到一起的过程为构建（Build）。但是在这样的开发过程中，我们往往会被这些复杂的集成工具所提供的强大功能所迷惑，很多系统软件的运行机制与机理被掩盖，其程序的很多莫名其妙的错误让我们无所适从，面对程序运行时种种性能瓶颈我们束手无策。如果能够深入了解这些机制，那么解决这些问题就能够游刃有余，收放自如了。</p>
<h1 id="被隐藏的过程"><a href="#被隐藏的过程" class="headerlink" title="被隐藏的过程"></a>被隐藏的过程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux下，当我们使用GCC来编译Hello World程序时，只需要最简单的命令我们便可以在屏幕上打印出“Hello World”字样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>事实上，上述过程可以分解为以下四个过程：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.staticaly.com/gh/hahahanba/hahahanba.github.io@main/images/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%88%86%E8%A7%A3.67oi1tq9bps0.webp"
                      alt="GCC编译过程分解"
                ></p>
<ul>
<li>预处理(Prepressing)</li>
<li>编译(Compilation)</li>
<li>汇编(Assembly)</li>
<li>链接(Linking)</li>
</ul>
<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预编译过程主要处理那些源代码文件中以“#”开始的预编译指令。比如<code>#include</code>、<code>#define</code>等，主要的处理规则如下：</p>
<ul>
<li>将所有的<code>#define</code>删除，并且展开所有的宏定义。</li>
<li>处理所有条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>。</li>
<li>处理<code>#include</code>预编译指令，将被包涵的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他的文件。</li>
<li>删除所有的注释<code>//</code>和<code>/**/</code>。</li>
<li>添加行号和文件名标识，比如<code>#2 hello.c 2</code>，以便编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的<code>#pragma</code>编译器指令，因为编译器要使用它们。</li>
</ul>
<p>我们可是使用如下的命令，将源代码文件<code>hello.c</code>和相关的头文件如<code>stdio.h</code>等被预编译器<code>cpp</code>预编译成一个<code>.i</code>文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i</span><br><span class="line">或者</span><br><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure>

<p>其<code>hello.i</code>文件如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">1</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">3</span></span><br><span class="line"># <span class="number">384</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">3</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command line&gt;&quot;</span> <span class="number">1</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">__uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">__int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">__uint16_t</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __vsnprintf_chk (<span class="type">char</span> * <span class="keyword">restrict</span>, <span class="type">size_t</span>, <span class="type">int</span>, <span class="type">size_t</span>,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span>, va_list);</span><br><span class="line"># <span class="number">417</span> <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">5</span> <span class="string">&quot;hello.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译过程就是把预处理完成的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。上面的编译过程相当于如下的命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.s</span><br><span class="line">或者</span><br><span class="line">$ gcc -S hello.c -o hello.s   <span class="comment">// 将预编译和编译合并</span></span><br></pre></td></tr></table></figure>

<p>汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.section	__TEXT,__text,regular,pure_instructions</span><br><span class="line">	.build_version macos, 13, 0	sdk_version 13, 3</span><br><span class="line">	.globl	_main                           ## -- Begin function main</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">_main:                                  ## @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line">## %bb.0:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movl	$0, -4(%rbp)</span><br><span class="line">	leaq	L_.str(%rip), %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_printf</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	addq	$16, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        ## -- End function</span><br><span class="line">	.section	__TEXT,__cstring,cstring_literals</span><br><span class="line">L_.str:                                 ## @.str</span><br><span class="line">	.asciz	&quot;Hello World\n&quot;</span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>

<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。上述汇编过程我们可以用一下命令完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ as hello.s -o hello.o.  <span class="comment">// as是汇编器</span></span><br><span class="line">或者</span><br><span class="line">$ gcc -c hello.s -o hello.o  </span><br><span class="line">或者</span><br><span class="line">$ gcc -c hello.c -o hello.o   <span class="comment">// 经过预编译、编译和汇编直接输出目标文件（Object File）</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>objdump -d hello.o </code>命令来查看 <code>.o</code>文件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.o:        file format mach-o 64-bit x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section __TEXT,__text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;_main&gt;:</span><br><span class="line">       0: 55                            pushq   %rbp</span><br><span class="line">       1: 48 89 e5                      movq    %rsp, %rbp</span><br><span class="line">       4: 48 83 ec 10                   subq    $16, %rsp</span><br><span class="line">       8: c7 45 fc 00 00 00 00          movl    $0, -4(%rbp)</span><br><span class="line">       f: 48 8d 3d 0f 00 00 00          leaq    15(%rip), %rdi          ## 0x25 &lt;_main+0x25&gt;</span><br><span class="line">      16: b0 00                         movb    $0, %al</span><br><span class="line">      18: e8 00 00 00 00                callq   0x1d &lt;_main+0x1d&gt;</span><br><span class="line">      1d: 31 c0                         xorl    %eax, %eax</span><br><span class="line">      1f: 48 83 c4 10                   addq    $16, %rsp</span><br><span class="line">      23: 5d                            popq    %rbp</span><br><span class="line">      24: c3                            retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>通常我们要将一大堆文件链接起来才可以得到<code>a.out</code>文件，即最终的可执行文件。我们可以通过以下命令来获取所有的编译选项：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc hello.c --verbose <span class="comment">// 或 gcc -v hello.c</span></span><br></pre></td></tr></table></figure>

<p>输出的编译信息含义可参考<a class="link"   href="https://stackoverflow.com/questions/13440549/gcc-verbose-mode-output-explanation" >gcc-verbose<i class="fas fa-external-link-alt"></i></a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>程序员的自我修养-链接，装载与库</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>链接，装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>目标文件有什么</title>
    <url>/2023/09/12/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="目标文件里有什么"><a href="#目标文件里有什么" class="headerlink" title="目标文件里有什么"></a>目标文件里有什么</h1><h2 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h2><p>现在PC平台流行的可执行文件格式（Executable）主要是Windows下的PE（Portable Executable）和Linux的ELF（Executable Linkable Format），它们都是COFF（Common file format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（Windows下的.obj和Linux下的.o），它跟可执行文件的内容与格式很相似，所以一般与可执行文件采用一种格式存储。</p>
<blockquote>
<p>COFF的主要贡献是在目标文件里面引入了“段”的机制，不同的目标文件可以拥有不同数量及不同类型的“段”。另外，它还定义了调试数据格式。</p>
</blockquote>
<p>不光是可执行文件（Windows的.exe和Linux下的ELF可执行文件）按照可执行文件格式存储。动态链接库（DLL，Dynamic Linking Library）（Windows的.dll和Linux的.so）及静态链接库（Static Linking Library）（Windows的.lib和Linux的.a）文件都按照可执行文件格式存储。它们在Windows下都按照PE-<strong>COFF格式</strong>存储，Linux下按照ELF格式存储。下表为系统中采用的ELF文件格式类型：</p>
<table>
<thead>
<tr>
<th align="center">ELF文件类型</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可重定位文件（Relocatable File）</td>
<td align="center">这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td>
<td align="center">Linux的.o Windows的.obj</td>
</tr>
<tr>
<td align="center">可执行文件（Executable File）</td>
<td align="center">这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，他们一般都没有扩展名</td>
<td align="center">比如&#x2F;bin&#x2F;bash文件  Windows的.exe</td>
</tr>
<tr>
<td align="center">共享目标文件 （Shared Object File）</td>
<td align="center">这种文件包含了代码和数据，可以在以下两种情况使用。一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接，产生可以将几个这种共享目标文件与可执行文件结合，作为进程影响的一部分来运行</td>
<td align="center">Linux的.so，如&#x2F;lib&#x2F;glibc-2.5.so Windows的DLL</td>
</tr>
<tr>
<td align="center">核心转储文件（Core Dump File）</td>
<td align="center">当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件</td>
<td align="center">Linux下的从core dump</td>
</tr>
</tbody></table>
<p>在Linux下，我们可以使用file命令来查看相应的文件格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ file hello.o</span><br><span class="line">hello.o: ELF <span class="number">64</span>-bit LSB relocatable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), not stripped</span><br><span class="line">$ file /bin/bash</span><br><span class="line">bash: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, BuildID[sha1]=<span class="number">6386b</span>644ab2d987986aeb40325a787a035a4f0d8, stripped</span><br></pre></td></tr></table></figure>

<h2 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h2><p>程序的源代码编译后的机器指令经常被放倒代码段（Code Section）里，代码段中常见的名字有<code>.code</code>,<code>.text</code>;全局变量和局部静态变量数据经常放在数据段（Data Section），数据段的一般名字都叫<code>.data</code>。一个简单的程序被编译成目标文件后的结构如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.staticaly.com/gh/hahahanba/hahahanba.github.io@main/images/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.24jflnm6juww.webp"
                     
                ></p>
<p>下面让我们来看看目标文件中具体会有什么。</p>
<h2 id="挖掘SimpleSection-o文件"><a href="#挖掘SimpleSection-o文件" class="headerlink" title="挖掘SimpleSection.o文件"></a>挖掘SimpleSection.o文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    func1(static_var + static_var2 + a+ b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以先将上述程序生成<code>.o</code>文件，然后利用objdump命令查看其ELF文件段的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -c SimpleSection.c</span><br><span class="line">$ objdump -h SimpleSection.o  <span class="comment">// 参数-h可以打印ELF文件各个段的基本信息</span></span><br><span class="line"></span><br><span class="line">SimpleSection.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000057</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000008</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000098</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a0  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .rodata       <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a0  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002</span>a  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a4  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>ce  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000058</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>d0  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure>

<p>从上面的结果来看，<code>SimpleSection.o</code>的段的数量比我们想象中的多，除了最基本的代码段、数据段和BSS段以外，还有4个段分别为只读数据段<code>.rodata</code>、注释信息段<code>.commit</code>、堆栈提示段<code>.note.GNU-stack</code>和堆栈回溯段<code>.eh_frame</code>。每个段的第一行容易理解的是段的长度（Size）和段所在的位置（File Offset），每个段中的第二行中的<code>CONTENTS</code>，<code>ALLOC</code>等标识段的各种属性，<code>CONTENTS</code>表示该段在文件中存在。我们可以看到BSS段没有<code>CONTENTS</code>，表示实际上在ELF文件中不存在内容。<code>.note.GNU-stack</code>段虽有<code>CONTENTS</code>，但长度为0。那么在ELF文件中实际存在的也就是<code>.text</code>、<code>.data</code>、<code>.rodata</code>、<code>.comment</code>和<code>.eh_frame</code>这5个段了。只考虑前四个段，那么它们在ELF中的结构如下图所示。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.staticaly.com/gh/hahahanba/hahahanba.github.io@main/images/SimpleSection.4v9l8qgq39k0.webp"
                      alt="SimpleSection"
                ></p>
<h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>我们可以利用objdump来查看代码段的内容。Contents of section .text 就是<code>.text</code>的十六进制内容，总共0x57字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -s可以将所有段的内容以十六进制的方式打印出来</span></span><br><span class="line"><span class="comment">// -d可以将所有包含指令的段反汇编</span></span><br><span class="line">$ objdump -s -d SimpleSection.o </span><br><span class="line">SimpleSection.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> <span class="number">0000</span> <span class="number">554889e5</span> <span class="number">4883</span>ec10 <span class="number">897</span>dfc8b <span class="number">45f</span>c89c6  UH..H....&#125;..E...</span><br><span class="line"> <span class="number">0010</span> <span class="number">488</span>d3d00 <span class="number">000000b</span>8 <span class="number">00000000</span> e8000000  H.=.............</span><br><span class="line"> <span class="number">0020</span> <span class="number">0090</span>c9c3 <span class="number">554889e5</span> <span class="number">4883</span>ec10 c745f801  ....UH..H....E..</span><br><span class="line"> <span class="number">0030</span> <span class="number">0000008b</span> <span class="number">15000000</span> <span class="number">008b</span>0500 <span class="number">00000001</span>  ................</span><br><span class="line"> <span class="number">0040</span> c28b45f8 <span class="number">01</span>c28b45 fc01d089 c7e80000  ..E....E........</span><br><span class="line"> <span class="number">0050</span> <span class="number">00008b</span>45 f8c9c3                      ...E...</span><br><span class="line">......</span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;func1&gt;:</span><br><span class="line">   <span class="number">0</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">   <span class="number">1</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">4</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>          	sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">8</span>:	<span class="number">89</span> <span class="number">7</span>d fc             	mov    %edi,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   b:	<span class="number">8b</span> <span class="number">45</span> fc             	mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">   e:	<span class="number">89</span> c6                	mov    %eax,%esi</span><br><span class="line">  <span class="number">10</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">3</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	lea    <span class="number">0x0</span>(%rip),%rdi        # <span class="number">17</span> &lt;func1+<span class="number">0x17</span>&gt;</span><br><span class="line">  <span class="number">17</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">1</span>c:	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">21</span> &lt;func1+<span class="number">0x21</span>&gt;</span><br><span class="line">  <span class="number">21</span>:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">22</span>:	c9                   	leaveq</span><br><span class="line">  <span class="number">23</span>:	c3                   	retq</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000024</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">24</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">25</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">  <span class="number">28</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>          	sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">2</span>c:	c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	movl   $<span class="number">0x1</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">33</span>:	<span class="number">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	mov    <span class="number">0x0</span>(%rip),%edx        # <span class="number">39</span> &lt;main+<span class="number">0x15</span>&gt;</span><br><span class="line">  <span class="number">39</span>:	<span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">3f</span> &lt;main+<span class="number">0x1b</span>&gt;</span><br><span class="line">  <span class="number">3f</span>:	<span class="number">01</span> c2                	add    %eax,%edx</span><br><span class="line">  <span class="number">41</span>:	<span class="number">8b</span> <span class="number">45</span> f8             	mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">44</span>:	<span class="number">01</span> c2                	add    %eax,%edx</span><br><span class="line">  <span class="number">46</span>:	<span class="number">8b</span> <span class="number">45</span> fc             	mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">49</span>:	<span class="number">01</span> d0                	add    %edx,%eax</span><br><span class="line">  <span class="number">4b</span>:	<span class="number">89</span> c7                	mov    %eax,%edi</span><br><span class="line">  <span class="number">4</span>d:	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">52</span> &lt;main+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">52</span>:	<span class="number">8b</span> <span class="number">45</span> f8             	mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">55</span>:	c9                   	leaveq</span><br><span class="line">  <span class="number">56</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<h3 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">Contents of section .data:</span><br><span class="line"> <span class="number">0000</span> <span class="number">54000000</span> <span class="number">55000000</span>                    T...U...</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> <span class="number">0000</span> <span class="number">25640</span>a00                             %d..</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>.data</code>段保存的是那些已经初始化了的全局变量和局部静态变量，分别为<code>global_init_varabal</code>、<code>static_var</code>，这两个变量每个4字节，一共8个字节，即<code>54000000</code>对应于十进制84，<code>55000000</code>对应于十进制85。另外，我们在程序中用到了一个字符串常量“%d\n”，它是一种只读数据，所以放到了<code>.rodata</code>段。</p>
<blockquote>
<p>.rodata段存放的只读数据一般是程序里面的只读变量（如const修饰的变量）和字符串常量。单独设立“.rodata”不光在语意上支持了c++的const关键字，而且操作系统在加载的时候可以将“.rodata”段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性。</p>
</blockquote>
<h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p><code>.bss</code>段保存的是未初始化的全局变量和局部静态变量，如<code>global_uninit_varabal</code>、<code>static_var2</code>。可以看到两个变量共占有8个字节，实际上该段的大小为4字节，这是因为不同的语言与不同的编译器实现有关，有的编译器会将全局的未初始化变量存放在<code>.bss</code>段，有的只是预留一个未定义的全局变量符号，等到最终链接成可执行文件的时候再在<code>.bss</code>段分配空间。（编译单元内部可见的静态变量的确是存放在<code>.bss</code>段）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a0  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  ALLOC</span><br></pre></td></tr></table></figure>

<h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><table>
<thead>
<tr>
<th>常用的段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.rodata1</td>
<td>跟.rodata一样</td>
</tr>
<tr>
<td>.comment</td>
<td>编译器版本信息，如GCC: (Ubuntu 7. 5.0-3ubuntu1~18.04) 7.5.0.</td>
</tr>
<tr>
<td>.debug</td>
<td>调试信息</td>
</tr>
<tr>
<td>.dynamic</td>
<td>动态链接信息</td>
</tr>
<tr>
<td>.hash</td>
<td>符号哈希表</td>
</tr>
<tr>
<td>.line</td>
<td>调试时的行号表，即源代码行号与编译后指令的对应表</td>
</tr>
<tr>
<td>.note</td>
<td>额外的编译器信息。如程序的公司名、发布的版本号等</td>
</tr>
<tr>
<td>.strtab</td>
<td>String Table字符串表，用于存储ELF文件中用到的各种字符串</td>
</tr>
<tr>
<td>.symtab</td>
<td>Symbol Table符号表</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>Section String Table段名表</td>
</tr>
<tr>
<td>.plt .got</td>
<td>动态链接的跳转表和全局入口表</td>
</tr>
<tr>
<td>.init .fini</td>
<td>程序初始化与终结代码段</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>程序员的自我修养-链接，装载与库</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>链接，装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF</title>
    <url>/2023/09/18/ELF/</url>
    <content><![CDATA[<h1 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h1><p>一个 ELF 文件通常有ELF文件头、段表、字符串表、符号表等组成，其总体结构如下图所示。不同的文件部分描述不同的文件内容：</p>
<ul>
<li>ELF文件头（ELF Header），它包含了描述整个文件的基本属性，如ELF文件版本、程序入口地址等。</li>
<li>ELF 文件中的各个段(section)。段表(section header table)描述了 ELF 文件包含的所有段的信息，包含每个段的段名、段的长度、在文件中的偏移量等属性。</li>
<li>其他一些辅助结构，如字符串表，符号表等。</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.staticaly.com/gh/hahahanba/hahahanba.github.io@main/images/ELF结构.2brdmca7kefw.webp"
                      alt="ELF" style="zoom:50%;" 
                >

<h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><p>在ELF文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。我们可以使用<code>readelf</code>命令来详细查看ELF文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$ readelf -h SimpleSection.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              <span class="built_in">REL</span> (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x0</span></span><br><span class="line">  Start of program headers:          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1104</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of <span class="keyword">this</span> header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">13</span></span><br><span class="line">  Section header string table index: <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>ELF文件头结构及相关常数被定义在<code>/usr/include/elf.h</code>中，为了兼容各种平台ELF文件有32位版本和64位版本，分别叫做<code>Elf32_Ehdr</code>、<code>Elf64_Ehdr</code>。同时<code>elf.h</code>使用typedef定义了一套自己的变量体系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Type for a 16-bit quantity.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf32_Half;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf64_Half;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Types for signed and unsigned 32-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  Elf32_Sword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  Elf64_Sword;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Types for signed and unsigned 64-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf32_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span>  Elf32_Sxword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span>  Elf64_Sxword;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type of addresses.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type of file offsets.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Off;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Off;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type for section indices, which are 16-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf32_Section;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf64_Section;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type for version symbol information.  */</span></span><br><span class="line"><span class="keyword">typedef</span> Elf32_Half Elf32_Versym;</span><br><span class="line"><span class="keyword">typedef</span> Elf64_Half Elf64_Versym;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT];     <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half    e_type;                 <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half    e_machine;              <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word    e_version;              <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr    e_entry;                <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off     e_phoff;                <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off     e_shoff;                <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word    e_flags;                <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half    e_ehsize;               <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half    e_phentsize;            <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half    e_phnum;                <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half    e_shentsize;            <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half    e_shnum;                <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half    e_shstrndx;             <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>

<h3 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h3><p>我们可以看到readelf的输出中最前面的<code>Magic</code>的16个字节刚好对应<code>Elf64_Ehdr</code>的<code>e_ident</code>这个成员。这16个字节用来标识ELF文件的平台属性，比如ELF字长、字节序、ELF文件版本等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>最开始的4个字节是所有ELF文件都必须相同的标识码，分别为<code>0x7F</code>、<code>0x45</code>、<code>0x4c</code>、<code>0x46</code>，第一个字节对应于ASCII字符里的<code>DEL</code>控制符，后面三个字对应ELF这3个字母的ASCII码。这四个字节又被称为ELF文件的魔数。通过对魔数的判断可以确定文件的格式和类型。如果被执行的是Shell脚本或perl、python等解释型语言的脚本，那么它的第一行往往是<code>#!/bin/sh</code>或<code>#!/usr/bin/perl</code>或<code>#!/usr/bin/python</code>，此时前两个字节<code>#</code>和<code>!</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序路径。</p>
<p>接下来的一个字节是用来标识ELF的文件类的，<code>0x01</code>、表示是32位，<code>0x02</code>表示是64位；第6个字是字节序，规定该文件是大端还是小端。第7个字节规定ELF文件的主版本号，一般是1。后面9个字节ELF标准没有定义，一般填0。</p>
<h2 id="ELF-Section-Header-Table"><a href="#ELF-Section-Header-Table" class="headerlink" title="ELF Section Header Table"></a>ELF Section Header Table</h2><p>ELF 段表保存了各个段的基本属性，是除了文件头之外最重要的结构，它描述了ELF中各个段的信息，如段名、段的大小、在文件中的偏移、读写权限等。<strong>编译器、链接器、装载器都是通过段表来定位和访问各个段的属性的。</strong></p>
<p>我们可以使用readelf工具来查看段表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$ readelf -S SimpleSection.o</span><br><span class="line">There are <span class="number">13</span> section headers, starting at offset <span class="number">0x450</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000040</span></span><br><span class="line">       <span class="number">0000000000000057</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">00000340</span></span><br><span class="line">       <span class="number">0000000000000078</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000098</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS           <span class="number">0000000000000000</span>  <span class="number">000000</span>a0</span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .rodata           PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a0</span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a4</span><br><span class="line">       <span class="number">000000000000002</span>a  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .note.GNU-stack   PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>ce</span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .eh_frame         PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>d0</span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .rela.eh_frame    RELA             <span class="number">0000000000000000</span>  <span class="number">000003b</span>8</span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">8</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00000128</span></span><br><span class="line">       <span class="number">0000000000000198</span>  <span class="number">0000000000000018</span>          <span class="number">11</span>    <span class="number">11</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">000002</span>c0</span><br><span class="line">       <span class="number">000000000000007</span>c  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">12</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">000003e8</span></span><br><span class="line">       <span class="number">0000000000000061</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  <span class="built_in">W</span> (write), <span class="built_in">A</span> (alloc), <span class="built_in">X</span> (execute), <span class="built_in">M</span> (merge), <span class="built_in">S</span> (strings), <span class="built_in">I</span> (info),</span><br><span class="line">  <span class="built_in">L</span> (link order), <span class="built_in">O</span> (extra OS processing required), <span class="built_in">G</span> (group), <span class="built_in">T</span> (TLS),</span><br><span class="line">  <span class="built_in">C</span> (compressed), <span class="built_in">x</span> (unknown), <span class="built_in">o</span> (OS specific), <span class="built_in">E</span> (exclude),</span><br><span class="line">  <span class="built_in">l</span> (large), <span class="built_in">p</span> (processor specific)</span><br></pre></td></tr></table></figure>

<p>段表的结构比较简单，它是一个以<code>Elf64_Shdr</code>结构体为元素的数组。数组的元素个数等于段的个数，每个<code>Elf64_Shdr</code>结构体对应一个段。<code>Elf64_Shdr</code>又被称为段描述符（Section Descriptor）。对于<code>SimpleSection.o</code>来说，段表就是有13个元素的数组，其中第一个元素是类型为<code>NULL</code>的无效段描述。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word    sh_name;                <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word    sh_type;                <span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xword   sh_flags;               <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addr    sh_addr;                <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off     sh_offset;              <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword   sh_size;                <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Word    sh_link;                <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word    sh_info;                <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword   sh_addralign;           <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword   sh_entsize;             <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<h3 id="段的类型"><a href="#段的类型" class="headerlink" title="段的类型"></a>段的类型</h3><p>段的名字只是在链接和编译过程中有意义，但它并不能真正地表示段的类型。对于编译器和链接器来说，主要决定段的属性是段的类型（<code>sh_type</code>）和段的标志位（<code>sh_flags</code>）。</p>
<p>段的类型相关常量以<code>SHT_</code>开头，常见的段类型如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHT_NULL</td>
<td align="left">0</td>
<td align="left">无效段</td>
</tr>
<tr>
<td align="left">SHT_PROGBITS</td>
<td align="left">1</td>
<td align="left"><strong>程序段</strong>。代码段、数据段都是这种类型。</td>
</tr>
<tr>
<td align="left">SHT_SYMTAB</td>
<td align="left">2</td>
<td align="left"><strong>符号表</strong></td>
</tr>
<tr>
<td align="left">SHT_STRTAB</td>
<td align="left">3</td>
<td align="left"><strong>字符串表</strong></td>
</tr>
<tr>
<td align="left">SHT_RELA</td>
<td align="left">4</td>
<td align="left"><strong>重定位表</strong>。该段包含了重定位信息。</td>
</tr>
<tr>
<td align="left">SHT_HASH</td>
<td align="left">5</td>
<td align="left"><strong>符号表的哈希表</strong></td>
</tr>
<tr>
<td align="left">SHT_DYNAMIC</td>
<td align="left">6</td>
<td align="left">动态链接信息</td>
</tr>
<tr>
<td align="left">SHT_NOTE</td>
<td align="left">7</td>
<td align="left">提示性信息</td>
</tr>
<tr>
<td align="left">SHT_NOBITS</td>
<td align="left">8</td>
<td align="left">表示该段在文件中没有内容。如&#96;.bss段</td>
</tr>
<tr>
<td align="left">SHT_REL</td>
<td align="left">9</td>
<td align="left">该段包含了重定位信息</td>
</tr>
<tr>
<td align="left">SHT_SHLIB</td>
<td align="left">10</td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">SHT_DNYSYM</td>
<td align="left">11</td>
<td align="left"><strong>动态链接的符号表</strong></td>
</tr>
</tbody></table>
<h3 id="段标志位（sh-flag）"><a href="#段标志位（sh-flag）" class="headerlink" title="段标志位（sh_flag）"></a>段标志位（sh_flag）</h3><p>段标志位表示该段在进程虚拟地址空间中的属性。如<strong>是否可写、是否可执行</strong>等。相关常量以<code>SHF_</code>开头。常见的段标志位如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHF_WRITE</td>
<td align="left">1</td>
<td align="left">表示该段在进程空间中可写</td>
</tr>
<tr>
<td align="left">SHF_ALLOC</td>
<td align="left">2</td>
<td align="left">表示该段在进程空间中需要分配空间。有些包含指示或控制信息的段不需要在进程空间中分配空间，就不会有这个标志。像代码段、数据段和.bss段都会有这个标志位。</td>
</tr>
<tr>
<td align="left">SHF_EXECINSTR</td>
<td align="left">4</td>
<td align="left">表示该段在进程空间中可以被执行，一般指代码段</td>
</tr>
</tbody></table>
<h3 id="段链接信息（sh-link、sh-info）"><a href="#段链接信息（sh-link、sh-info）" class="headerlink" title="段链接信息（sh_link、sh_info）"></a>段链接信息（sh_link、sh_info）</h3><p>如果段的类型是与链接相关的（无论是动态链接还是静态链接），如<strong>重定位表、符号表、</strong>等，则<code>sh_link</code>、<code>sh_info</code>两个成员所包含的意义如下所示。其他类型的段，这两个成员没有意义。</p>
<table>
<thead>
<tr>
<th align="left">sh_type</th>
<th align="left">sh_link</th>
<th align="left">sh_info</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHT_DYNAMIC</td>
<td align="left">该段所使用的<strong>字符串表</strong>在段表中的下标</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SHT_HASH</td>
<td align="left">该段所使用的<strong>符号表</strong>在段表中的下标</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SHT_REL</td>
<td align="left">该段所使用的<strong>相应符号表</strong>在段表中的下标</td>
<td align="left">该重定位表所作用的段在段表中的下标</td>
</tr>
<tr>
<td align="left">SHT_RELA</td>
<td align="left">该段所使用的<strong>相应符号表</strong>在段表中的下标</td>
<td align="left">该重定位表所作用的段在段表中的下标</td>
</tr>
<tr>
<td align="left">SHT_SYMTAB</td>
<td align="left">操作系统相关</td>
<td align="left">操作系统相关</td>
</tr>
<tr>
<td align="left">SHT_DYNSYM</td>
<td align="left">操作系统相关</td>
<td align="left">操作系统相关</td>
</tr>
<tr>
<td align="left">other</td>
<td align="left">SHN_UNDEF</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>链接器在处理目标文件时须要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。对于每个需要重定位的代码段和数据段都会有一个相应的重定位表。一个重定位表同时也是ELF的一个段，那么这个段的类型就是<code>SHT_REL</code>或者<code>SHT_RELA</code>，它的<code>sh_link</code>表示符号表的下标，它的<code>sh_info</code>表示它作用于哪一个段。比如<code>.rela.text</code>作用于<code>.text</code>段，而<code>.text</code>的下标为1，那么<code>.rela.text</code>的<code>sh_info</code>为1。</p>
<h2 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h2><p>ELF文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。比如下述这个字符串表：</p>
<table>
<thead>
<tr>
<th>偏移</th>
<th>+0</th>
<th>+1</th>
<th>+2</th>
<th>+3</th>
<th>+4</th>
<th>+5</th>
<th>+6</th>
<th>+7</th>
<th>+8</th>
<th>+9</th>
</tr>
</thead>
<tbody><tr>
<td>+0</td>
<td>\0</td>
<td>h</td>
<td>e</td>
<td>l</td>
<td>l</td>
<td>o</td>
<td>w</td>
<td>o</td>
<td>r</td>
<td>l</td>
</tr>
<tr>
<td>+10</td>
<td>d</td>
<td>\0</td>
<td>M</td>
<td>y</td>
<td>v</td>
<td>a</td>
<td>r</td>
<td>i</td>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>+20</td>
<td>l</td>
<td>e</td>
<td>\0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>那么偏移与它们对应的字符串如下表所示：</p>
<table>
<thead>
<tr>
<th>偏移</th>
<th>字符串</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>空字符串</td>
</tr>
<tr>
<td>1</td>
<td>helloworld</td>
</tr>
<tr>
<td>6</td>
<td>world</td>
</tr>
<tr>
<td>12</td>
<td>Myvariable</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a class="link"   href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" >Executable and Linkable Format<i class="fas fa-external-link-alt"></i></a></li>
<li>《程序员的自我修养——链接、装载与库》</li>
<li><a class="link"   href="https://man7.org/linux/man-pages/man5/elf.5.html" >ELF man page<i class="fas fa-external-link-alt"></i></a></li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>链接，装载与库</tag>
      </tags>
  </entry>
</search>
