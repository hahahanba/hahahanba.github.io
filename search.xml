<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编译和链接</title>
    <url>/2023/09/08/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>对于平常的应用程序开发，我们很少需要关注编译与链接过程。因为通常的开发环境都是流行的集成开发环境（IDE），比如Visual Studio等。这样的IDE一般都将编译和链接的过程一步完成，通常这种编译和链接合并到一起的过程为构建（Build）。但是在这样的开发过程中，我们往往会被这些复杂的集成工具所提供的强大功能所迷惑，很多系统软件的运行机制与机理被掩盖，其程序的很多莫名其妙的错误让我们无所适从，面对程序运行时种种性能瓶颈我们束手无策。如果能够深入了解这些机制，那么解决这些问题就能够游刃有余，收放自如了。</p>
<h1 id="被隐藏的过程"><a href="#被隐藏的过程" class="headerlink" title="被隐藏的过程"></a>被隐藏的过程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux下，当我们使用GCC来编译Hello World程序时，只需要最简单的命令我们便可以在屏幕上打印出“Hello World”字样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>事实上，上述过程可以分解为以下四个过程：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/zCDmOzz.png"
                      alt="GCC编译过程分解"
                >)</p>
<ul>
<li>预处理(Prepressing)</li>
<li>编译(Compilation)</li>
<li>汇编(Assembly)</li>
<li>链接(Linking)</li>
</ul>
<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预编译过程主要处理那些源代码文件中以“#”开始的预编译指令。比如<code>#include</code>、<code>#define</code>等，主要的处理规则如下：</p>
<ul>
<li>将所有的<code>#define</code>删除，并且展开所有的宏定义。</li>
<li>处理所有条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>。</li>
<li>处理<code>#include</code>预编译指令，将被包涵的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他的文件。</li>
<li>删除所有的注释<code>//</code>和<code>/**/</code>。</li>
<li>添加行号和文件名标识，比如<code>#2 hello.c 2</code>，以便编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的<code>#pragma</code>编译器指令，因为编译器要使用它们。</li>
</ul>
<p>我们可是使用如下的命令，将源代码文件<code>hello.c</code>和相关的头文件如<code>stdio.h</code>等被预编译器<code>cpp</code>预编译成一个<code>.i</code>文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i</span><br><span class="line">或者</span><br><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure>

<p>其<code>hello.i</code>文件如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">1</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">3</span></span><br><span class="line"># <span class="number">384</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">3</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command line&gt;&quot;</span> <span class="number">1</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">__uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">__int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">__uint16_t</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __vsnprintf_chk (<span class="type">char</span> * <span class="keyword">restrict</span>, <span class="type">size_t</span>, <span class="type">int</span>, <span class="type">size_t</span>,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span>, va_list);</span><br><span class="line"># <span class="number">417</span> <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">5</span> <span class="string">&quot;hello.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译过程就是把预处理完成的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。上面的编译过程相当于如下的命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.s</span><br><span class="line">或者</span><br><span class="line">$ gcc -S hello.c -o hello.s   <span class="comment">// 将预编译和编译合并</span></span><br></pre></td></tr></table></figure>

<p>汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.section	__TEXT,__text,regular,pure_instructions</span><br><span class="line">	.build_version macos, 13, 0	sdk_version 13, 3</span><br><span class="line">	.globl	_main                           ## -- Begin function main</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">_main:                                  ## @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line">## %bb.0:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movl	$0, -4(%rbp)</span><br><span class="line">	leaq	L_.str(%rip), %rdi</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_printf</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	addq	$16, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        ## -- End function</span><br><span class="line">	.section	__TEXT,__cstring,cstring_literals</span><br><span class="line">L_.str:                                 ## @.str</span><br><span class="line">	.asciz	&quot;Hello World\n&quot;</span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>

<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。上述汇编过程我们可以用一下命令完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ as hello.s -o hello.o.  <span class="comment">// as是汇编器</span></span><br><span class="line">或者</span><br><span class="line">$ gcc -c hello.s -o hello.o  </span><br><span class="line">或者</span><br><span class="line">$ gcc -c hello.c -o hello.o   <span class="comment">// 经过预编译、编译和汇编直接输出目标文件（Object File）</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>objdump -d hello.o </code>命令来查看 <code>.o</code>文件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.o:        file format mach-o 64-bit x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section __TEXT,__text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;_main&gt;:</span><br><span class="line">       0: 55                            pushq   %rbp</span><br><span class="line">       1: 48 89 e5                      movq    %rsp, %rbp</span><br><span class="line">       4: 48 83 ec 10                   subq    $16, %rsp</span><br><span class="line">       8: c7 45 fc 00 00 00 00          movl    $0, -4(%rbp)</span><br><span class="line">       f: 48 8d 3d 0f 00 00 00          leaq    15(%rip), %rdi          ## 0x25 &lt;_main+0x25&gt;</span><br><span class="line">      16: b0 00                         movb    $0, %al</span><br><span class="line">      18: e8 00 00 00 00                callq   0x1d &lt;_main+0x1d&gt;</span><br><span class="line">      1d: 31 c0                         xorl    %eax, %eax</span><br><span class="line">      1f: 48 83 c4 10                   addq    $16, %rsp</span><br><span class="line">      23: 5d                            popq    %rbp</span><br><span class="line">      24: c3                            retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>通常我们要将一大堆文件链接起来才可以得到<code>a.out</code>文件，即最终的可执行文件。我们可以通过以下命令来获取所有的编译选项：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc hello.c --verbose <span class="comment">// 或 gcc -v hello.c</span></span><br></pre></td></tr></table></figure>

<p>输出的编译信息含义可参考<a class="link"   href="https://stackoverflow.com/questions/13440549/gcc-verbose-mode-output-explanation" >gcc-verbose<i class="fas fa-external-link-alt"></i></a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>程序员的自我修养-链接，装载与库</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>链接，装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>目标文件有什么</title>
    <url>/2023/09/12/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="目标文件里有什么"><a href="#目标文件里有什么" class="headerlink" title="目标文件里有什么"></a>目标文件里有什么</h1><h2 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h2><p>现在PC平台流行的可执行文件格式（Executable）主要是Windows下的PE（Portable Executable）和Linux的ELF（Executable Linkable Format），它们都是COFF（Common file format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（Windows下的.obj和Linux下的.o），它跟可执行文件的内容与格式很相似，所以一般与可执行文件采用一种格式存储。</p>
<blockquote>
<p>COFF的主要贡献是在目标文件里面引入了“段”的机制，不同的目标文件可以拥有不同数量及不同类型的“段”。另外，它还定义了调试数据格式。</p>
</blockquote>
<p>不光是可执行文件（Windows的.exe和Linux下的ELF可执行文件）按照可执行文件格式存储。动态链接库（DLL，Dynamic Linking Library）（Windows的.dll和Linux的.so）及静态链接库（Static Linking Library）（Windows的.lib和Linux的.a）文件都按照可执行文件格式存储。它们在Windows下都按照PE-<strong>COFF格式</strong>存储，Linux下按照ELF格式存储。下表为系统中采用的ELF文件格式类型：</p>
<table>
<thead>
<tr>
<th align="center">ELF文件类型</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可重定位文件（Relocatable File）</td>
<td align="center">这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td>
<td align="center">Linux的.o Windows的.obj</td>
</tr>
<tr>
<td align="center">可执行文件（Executable File）</td>
<td align="center">这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，他们一般都没有扩展名</td>
<td align="center">比如&#x2F;bin&#x2F;bash文件  Windows的.exe</td>
</tr>
<tr>
<td align="center">共享目标文件 （Shared Object File）</td>
<td align="center">这种文件包含了代码和数据，可以在以下两种情况使用。一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接，产生可以将几个这种共享目标文件与可执行文件结合，作为进程影响的一部分来运行</td>
<td align="center">Linux的.so，如&#x2F;lib&#x2F;glibc-2.5.so Windows的DLL</td>
</tr>
<tr>
<td align="center">核心转储文件（Core Dump File）</td>
<td align="center">当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件</td>
<td align="center">Linux下的从core dump</td>
</tr>
</tbody></table>
<p>在Linux下，我们可以使用file命令来查看相应的文件格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ file hello.o</span><br><span class="line">hello.o: ELF <span class="number">64</span>-bit LSB relocatable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), not stripped</span><br><span class="line">$ file /bin/bash</span><br><span class="line">bash: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, BuildID[sha1]=<span class="number">6386b</span>644ab2d987986aeb40325a787a035a4f0d8, stripped</span><br></pre></td></tr></table></figure>

<h2 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h2><p>程序的源代码编译后的机器指令经常被放倒代码段（Code Section）里，代码段中常见的名字有<code>.code</code>,<code>.text</code>;全局变量和局部静态变量数据经常放在数据段（Data Section），数据段的一般名字都叫<code>.data</code>。一个简单的程序被编译成目标文件后的结构如下图所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/39Eywnj.png"
                      alt="Imgur"
                >)</p>
<p>下面让我们来看看目标文件中具体会有什么。</p>
<h2 id="挖掘SimpleSection-o文件"><a href="#挖掘SimpleSection-o文件" class="headerlink" title="挖掘SimpleSection.o文件"></a>挖掘SimpleSection.o文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    func1(static_var + static_var2 + a+ b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以先将上述程序生成<code>.o</code>文件，然后利用objdump命令查看其ELF文件段的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -c SimpleSection.c</span><br><span class="line">$ objdump -h SimpleSection.o  <span class="comment">// 参数-h可以打印ELF文件各个段的基本信息</span></span><br><span class="line"></span><br><span class="line">SimpleSection.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000057</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000008</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000098</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a0  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .rodata       <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a0  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002</span>a  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a4  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>ce  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000058</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>d0  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure>

<p>从上面的结果来看，<code>SimpleSection.o</code>的段的数量比我们想象中的多，除了最基本的代码段、数据段和BSS段以外，还有4个段分别为只读数据段<code>.rodata</code>、注释信息段<code>.commit</code>、堆栈提示段<code>.note.GNU-stack</code>和堆栈回溯段<code>.eh_frame</code>。每个段的第一行容易理解的是段的长度（Size）和段所在的位置（File Offset），每个段中的第二行中的<code>CONTENTS</code>，<code>ALLOC</code>等标识段的各种属性，<code>CONTENTS</code>表示该段在文件中存在。我们可以看到BSS段没有<code>CONTENTS</code>，表示实际上在ELF文件中不存在内容。<code>.note.GNU-stack</code>段虽有<code>CONTENTS</code>，但长度为0。那么在ELF文件中实际存在的也就是<code>.text</code>、<code>.data</code>、<code>.rodata</code>、<code>.comment</code>和<code>.eh_frame</code>这5个段了。只考虑前四个段，那么它们在ELF中的结构如下图所示。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/4vlZvM7.png"
                      alt="Imgur"
                ></p>
<h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>我们可以利用objdump来查看代码段的内容。Contents of section .text 就是<code>.text</code>的十六进制内容，总共0x57字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -s可以将所有段的内容以十六进制的方式打印出来</span></span><br><span class="line"><span class="comment">// -d可以将所有包含指令的段反汇编</span></span><br><span class="line">$ objdump -s -d SimpleSection.o </span><br><span class="line">SimpleSection.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> <span class="number">0000</span> <span class="number">554889e5</span> <span class="number">4883</span>ec10 <span class="number">897</span>dfc8b <span class="number">45f</span>c89c6  UH..H....&#125;..E...</span><br><span class="line"> <span class="number">0010</span> <span class="number">488</span>d3d00 <span class="number">000000b</span>8 <span class="number">00000000</span> e8000000  H.=.............</span><br><span class="line"> <span class="number">0020</span> <span class="number">0090</span>c9c3 <span class="number">554889e5</span> <span class="number">4883</span>ec10 c745f801  ....UH..H....E..</span><br><span class="line"> <span class="number">0030</span> <span class="number">0000008b</span> <span class="number">15000000</span> <span class="number">008b</span>0500 <span class="number">00000001</span>  ................</span><br><span class="line"> <span class="number">0040</span> c28b45f8 <span class="number">01</span>c28b45 fc01d089 c7e80000  ..E....E........</span><br><span class="line"> <span class="number">0050</span> <span class="number">00008b</span>45 f8c9c3                      ...E...</span><br><span class="line">......</span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;func1&gt;:</span><br><span class="line">   <span class="number">0</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">   <span class="number">1</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">4</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>          	sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">8</span>:	<span class="number">89</span> <span class="number">7</span>d fc             	mov    %edi,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   b:	<span class="number">8b</span> <span class="number">45</span> fc             	mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">   e:	<span class="number">89</span> c6                	mov    %eax,%esi</span><br><span class="line">  <span class="number">10</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">3</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	lea    <span class="number">0x0</span>(%rip),%rdi        # <span class="number">17</span> &lt;func1+<span class="number">0x17</span>&gt;</span><br><span class="line">  <span class="number">17</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">1</span>c:	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">21</span> &lt;func1+<span class="number">0x21</span>&gt;</span><br><span class="line">  <span class="number">21</span>:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">22</span>:	c9                   	leaveq</span><br><span class="line">  <span class="number">23</span>:	c3                   	retq</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000024</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">24</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">25</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">  <span class="number">28</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>          	sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">2</span>c:	c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	movl   $<span class="number">0x1</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">33</span>:	<span class="number">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	mov    <span class="number">0x0</span>(%rip),%edx        # <span class="number">39</span> &lt;main+<span class="number">0x15</span>&gt;</span><br><span class="line">  <span class="number">39</span>:	<span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">3f</span> &lt;main+<span class="number">0x1b</span>&gt;</span><br><span class="line">  <span class="number">3f</span>:	<span class="number">01</span> c2                	add    %eax,%edx</span><br><span class="line">  <span class="number">41</span>:	<span class="number">8b</span> <span class="number">45</span> f8             	mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">44</span>:	<span class="number">01</span> c2                	add    %eax,%edx</span><br><span class="line">  <span class="number">46</span>:	<span class="number">8b</span> <span class="number">45</span> fc             	mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">49</span>:	<span class="number">01</span> d0                	add    %edx,%eax</span><br><span class="line">  <span class="number">4b</span>:	<span class="number">89</span> c7                	mov    %eax,%edi</span><br><span class="line">  <span class="number">4</span>d:	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">52</span> &lt;main+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">52</span>:	<span class="number">8b</span> <span class="number">45</span> f8             	mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">55</span>:	c9                   	leaveq</span><br><span class="line">  <span class="number">56</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<h3 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">Contents of section .data:</span><br><span class="line"> <span class="number">0000</span> <span class="number">54000000</span> <span class="number">55000000</span>                    T...U...</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> <span class="number">0000</span> <span class="number">25640</span>a00                             %d..</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>.data</code>段保存的是那些已经初始化了的全局变量和局部静态变量，分别为<code>global_init_varabal</code>、<code>static_var</code>，这两个变量每个4字节，一共8个字节，即<code>54000000</code>对应于十进制84，<code>55000000</code>对应于十进制85。另外，我们在程序中用到了一个字符串常量“%d\n”，它是一种只读数据，所以放到了<code>.rodata</code>段。</p>
<blockquote>
<p>.rodata段存放的只读数据一般是程序里面的只读变量（如const修饰的变量）和字符串常量。单独设立“.rodata”不光在语意上支持了c++的const关键字，而且操作系统在加载的时候可以将“.rodata”段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性。</p>
</blockquote>
<h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p><code>.bss</code>段保存的是未初始化的全局变量和局部静态变量，如<code>global_uninit_varabal</code>、<code>static_var2</code>。可以看到两个变量共占有8个字节，实际上该段的大小为4字节，这是因为不同的语言与不同的编译器实现有关，有的编译器会将全局的未初始化变量存放在<code>.bss</code>段，有的只是预留一个未定义的全局变量符号，等到最终链接成可执行文件的时候再在<code>.bss</code>段分配空间。（编译单元内部可见的静态变量的确是存放在<code>.bss</code>段）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a0  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  ALLOC</span><br></pre></td></tr></table></figure>

<h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><table>
<thead>
<tr>
<th>常用的段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.rodata1</td>
<td>跟.rodata一样</td>
</tr>
<tr>
<td>.comment</td>
<td>编译器版本信息，如GCC: (Ubuntu 7. 5.0-3ubuntu1~18.04) 7.5.0.</td>
</tr>
<tr>
<td>.debug</td>
<td>调试信息</td>
</tr>
<tr>
<td>.dynamic</td>
<td>动态链接信息</td>
</tr>
<tr>
<td>.hash</td>
<td>符号哈希表</td>
</tr>
<tr>
<td>.line</td>
<td>调试时的行号表，即源代码行号与编译后指令的对应表</td>
</tr>
<tr>
<td>.note</td>
<td>额外的编译器信息。如程序的公司名、发布的版本号等</td>
</tr>
<tr>
<td>.strtab</td>
<td>String Table字符串表，用于存储ELF文件中用到的各种字符串</td>
</tr>
<tr>
<td>.symtab</td>
<td>Symbol Table符号表</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>Section String Table段名表</td>
</tr>
<tr>
<td>.plt .got</td>
<td>动态链接的跳转表和全局入口表</td>
</tr>
<tr>
<td>.init .fini</td>
<td>程序初始化与终结代码段</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>程序员的自我修养-链接，装载与库</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>链接，装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF</title>
    <url>/2023/09/18/ELF/</url>
    <content><![CDATA[<h1 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h1><p>一个 ELF 文件通常有ELF文件头、段表、字符串表、符号表等组成，其总体结构如下图所示。不同的文件部分描述不同的文件内容：</p>
<ul>
<li>ELF文件头（ELF Header），它包含了描述整个文件的基本属性，如ELF文件版本、程序入口地址等。</li>
<li>ELF 文件中的各个段(section)。段表(section header table)描述了 ELF 文件包含的所有段的信息，包含每个段的段名、段的长度、在文件中的偏移量等属性。</li>
<li>其他一些辅助结构，如字符串表，符号表等。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/IcTOBHt.png"
                      alt="Imgur"
                ></p>
<h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><p>在ELF文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。我们可以使用<code>readelf</code>命令来详细查看ELF文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$ readelf -h SimpleSection.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              <span class="built_in">REL</span> (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x0</span></span><br><span class="line">  Start of program headers:          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1104</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of <span class="keyword">this</span> header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">13</span></span><br><span class="line">  Section header string table index: <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>ELF文件头结构及相关常数被定义在<code>/usr/include/elf.h</code>中，为了兼容各种平台ELF文件有32位版本和64位版本，分别叫做<code>Elf32_Ehdr</code>、<code>Elf64_Ehdr</code>。同时<code>elf.h</code>使用typedef定义了一套自己的变量体系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Type for a 16-bit quantity.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf32_Half;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf64_Half;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Types for signed and unsigned 32-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  Elf32_Sword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  Elf64_Sword;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Types for signed and unsigned 64-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf32_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span>  Elf32_Sxword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span>  Elf64_Sxword;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type of addresses.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type of file offsets.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Off;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Elf64_Off;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type for section indices, which are 16-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf32_Section;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf64_Section;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type for version symbol information.  */</span></span><br><span class="line"><span class="keyword">typedef</span> Elf32_Half Elf32_Versym;</span><br><span class="line"><span class="keyword">typedef</span> Elf64_Half Elf64_Versym;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT];     <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half    e_type;                 <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half    e_machine;              <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word    e_version;              <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr    e_entry;                <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off     e_phoff;                <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off     e_shoff;                <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word    e_flags;                <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half    e_ehsize;               <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half    e_phentsize;            <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half    e_phnum;                <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half    e_shentsize;            <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half    e_shnum;                <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half    e_shstrndx;             <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>

<h3 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h3><p>我们可以看到readelf的输出中最前面的<code>Magic</code>的16个字节刚好对应<code>Elf64_Ehdr</code>的<code>e_ident</code>这个成员。这16个字节用来标识ELF文件的平台属性，比如ELF字长、字节序、ELF文件版本等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>最开始的4个字节是所有ELF文件都必须相同的标识码，分别为<code>0x7F</code>、<code>0x45</code>、<code>0x4c</code>、<code>0x46</code>，第一个字节对应于ASCII字符里的<code>DEL</code>控制符，后面三个字对应ELF这3个字母的ASCII码。这四个字节又被称为ELF文件的魔数。通过对魔数的判断可以确定文件的格式和类型。如果被执行的是Shell脚本或perl、python等解释型语言的脚本，那么它的第一行往往是<code>#!/bin/sh</code>或<code>#!/usr/bin/perl</code>或<code>#!/usr/bin/python</code>，此时前两个字节<code>#</code>和<code>!</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序路径。</p>
<p>接下来的一个字节是用来标识ELF的文件类的，<code>0x01</code>、表示是32位，<code>0x02</code>表示是64位；第6个字是字节序，规定该文件是大端还是小端。第7个字节规定ELF文件的主版本号，一般是1。后面9个字节ELF标准没有定义，一般填0。</p>
<h2 id="ELF-Section-Header-Table"><a href="#ELF-Section-Header-Table" class="headerlink" title="ELF Section Header Table"></a>ELF Section Header Table</h2><p>ELF 段表保存了各个段的基本属性，是除了文件头之外最重要的结构，它描述了ELF中各个段的信息，如段名、段的大小、在文件中的偏移、读写权限等。<strong>编译器、链接器、装载器都是通过段表来定位和访问各个段的属性的。</strong></p>
<p>我们可以使用readelf工具来查看段表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$ readelf -S SimpleSection.o</span><br><span class="line">There are <span class="number">13</span> section headers, starting at offset <span class="number">0x450</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000040</span></span><br><span class="line">       <span class="number">0000000000000057</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">00000340</span></span><br><span class="line">       <span class="number">0000000000000078</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000098</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS           <span class="number">0000000000000000</span>  <span class="number">000000</span>a0</span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .rodata           PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a0</span><br><span class="line">       <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a4</span><br><span class="line">       <span class="number">000000000000002</span>a  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .note.GNU-stack   PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>ce</span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">8</span>] .eh_frame         PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>d0</span><br><span class="line">       <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .rela.eh_frame    RELA             <span class="number">0000000000000000</span>  <span class="number">000003b</span>8</span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">8</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00000128</span></span><br><span class="line">       <span class="number">0000000000000198</span>  <span class="number">0000000000000018</span>          <span class="number">11</span>    <span class="number">11</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">000002</span>c0</span><br><span class="line">       <span class="number">000000000000007</span>c  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">12</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">000003e8</span></span><br><span class="line">       <span class="number">0000000000000061</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  <span class="built_in">W</span> (write), <span class="built_in">A</span> (alloc), <span class="built_in">X</span> (execute), <span class="built_in">M</span> (merge), <span class="built_in">S</span> (strings), <span class="built_in">I</span> (info),</span><br><span class="line">  <span class="built_in">L</span> (link order), <span class="built_in">O</span> (extra OS processing required), <span class="built_in">G</span> (group), <span class="built_in">T</span> (TLS),</span><br><span class="line">  <span class="built_in">C</span> (compressed), <span class="built_in">x</span> (unknown), <span class="built_in">o</span> (OS specific), <span class="built_in">E</span> (exclude),</span><br><span class="line">  <span class="built_in">l</span> (large), <span class="built_in">p</span> (processor specific)</span><br></pre></td></tr></table></figure>

<p>段表的结构比较简单，它是一个以<code>Elf64_Shdr</code>结构体为元素的数组。数组的元素个数等于段的个数，每个<code>Elf64_Shdr</code>结构体对应一个段。<code>Elf64_Shdr</code>又被称为段描述符（Section Descriptor）。对于<code>SimpleSection.o</code>来说，段表就是有13个元素的数组，其中第一个元素是类型为<code>NULL</code>的无效段描述。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word    sh_name;                <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word    sh_type;                <span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xword   sh_flags;               <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addr    sh_addr;                <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off     sh_offset;              <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword   sh_size;                <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Word    sh_link;                <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word    sh_info;                <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword   sh_addralign;           <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword   sh_entsize;             <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<h3 id="段的类型"><a href="#段的类型" class="headerlink" title="段的类型"></a>段的类型</h3><p>段的名字只是在链接和编译过程中有意义，但它并不能真正地表示段的类型。对于编译器和链接器来说，主要决定段的属性是段的类型（<code>sh_type</code>）和段的标志位（<code>sh_flags</code>）。</p>
<p>段的类型相关常量以<code>SHT_</code>开头，常见的段类型如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHT_NULL</td>
<td align="left">0</td>
<td align="left">无效段</td>
</tr>
<tr>
<td align="left">SHT_PROGBITS</td>
<td align="left">1</td>
<td align="left"><strong>程序段</strong>。代码段、数据段都是这种类型。</td>
</tr>
<tr>
<td align="left">SHT_SYMTAB</td>
<td align="left">2</td>
<td align="left"><strong>符号表</strong></td>
</tr>
<tr>
<td align="left">SHT_STRTAB</td>
<td align="left">3</td>
<td align="left"><strong>字符串表</strong></td>
</tr>
<tr>
<td align="left">SHT_RELA</td>
<td align="left">4</td>
<td align="left"><strong>重定位表</strong>。该段包含了重定位信息。</td>
</tr>
<tr>
<td align="left">SHT_HASH</td>
<td align="left">5</td>
<td align="left"><strong>符号表的哈希表</strong></td>
</tr>
<tr>
<td align="left">SHT_DYNAMIC</td>
<td align="left">6</td>
<td align="left">动态链接信息</td>
</tr>
<tr>
<td align="left">SHT_NOTE</td>
<td align="left">7</td>
<td align="left">提示性信息</td>
</tr>
<tr>
<td align="left">SHT_NOBITS</td>
<td align="left">8</td>
<td align="left">表示该段在文件中没有内容。如&#96;.bss段</td>
</tr>
<tr>
<td align="left">SHT_REL</td>
<td align="left">9</td>
<td align="left">该段包含了重定位信息</td>
</tr>
<tr>
<td align="left">SHT_SHLIB</td>
<td align="left">10</td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">SHT_DNYSYM</td>
<td align="left">11</td>
<td align="left"><strong>动态链接的符号表</strong></td>
</tr>
</tbody></table>
<h3 id="段标志位（sh-flag）"><a href="#段标志位（sh-flag）" class="headerlink" title="段标志位（sh_flag）"></a>段标志位（sh_flag）</h3><p>段标志位表示该段在进程虚拟地址空间中的属性。如<strong>是否可写、是否可执行</strong>等。相关常量以<code>SHF_</code>开头。常见的段标志位如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHF_WRITE</td>
<td align="left">1</td>
<td align="left">表示该段在进程空间中可写</td>
</tr>
<tr>
<td align="left">SHF_ALLOC</td>
<td align="left">2</td>
<td align="left">表示该段在进程空间中需要分配空间。有些包含指示或控制信息的段不需要在进程空间中分配空间，就不会有这个标志。像代码段、数据段和.bss段都会有这个标志位。</td>
</tr>
<tr>
<td align="left">SHF_EXECINSTR</td>
<td align="left">4</td>
<td align="left">表示该段在进程空间中可以被执行，一般指代码段</td>
</tr>
</tbody></table>
<h3 id="段链接信息（sh-link、sh-info）"><a href="#段链接信息（sh-link、sh-info）" class="headerlink" title="段链接信息（sh_link、sh_info）"></a>段链接信息（sh_link、sh_info）</h3><p>如果段的类型是与链接相关的（无论是动态链接还是静态链接），如<strong>重定位表、符号表、</strong>等，则<code>sh_link</code>、<code>sh_info</code>两个成员所包含的意义如下所示。其他类型的段，这两个成员没有意义。</p>
<table>
<thead>
<tr>
<th align="left">sh_type</th>
<th align="left">sh_link</th>
<th align="left">sh_info</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHT_DYNAMIC</td>
<td align="left">该段所使用的<strong>字符串表</strong>在段表中的下标</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SHT_HASH</td>
<td align="left">该段所使用的<strong>符号表</strong>在段表中的下标</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SHT_REL</td>
<td align="left">该段所使用的<strong>相应符号表</strong>在段表中的下标</td>
<td align="left">该重定位表所作用的段在段表中的下标</td>
</tr>
<tr>
<td align="left">SHT_RELA</td>
<td align="left">该段所使用的<strong>相应符号表</strong>在段表中的下标</td>
<td align="left">该重定位表所作用的段在段表中的下标</td>
</tr>
<tr>
<td align="left">SHT_SYMTAB</td>
<td align="left">操作系统相关</td>
<td align="left">操作系统相关</td>
</tr>
<tr>
<td align="left">SHT_DYNSYM</td>
<td align="left">操作系统相关</td>
<td align="left">操作系统相关</td>
</tr>
<tr>
<td align="left">other</td>
<td align="left">SHN_UNDEF</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>链接器在处理目标文件时须要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。对于每个需要重定位的代码段和数据段都会有一个相应的重定位表。一个重定位表同时也是ELF的一个段，那么这个段的类型就是<code>SHT_REL</code>或者<code>SHT_RELA</code>，它的<code>sh_link</code>表示符号表的下标，它的<code>sh_info</code>表示它作用于哪一个段。比如<code>.rela.text</code>作用于<code>.text</code>段，而<code>.text</code>的下标为1，那么<code>.rela.text</code>的<code>sh_info</code>为1。</p>
<h2 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h2><p>ELF文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。比如下述这个字符串表：</p>
<table>
<thead>
<tr>
<th>偏移</th>
<th>+0</th>
<th>+1</th>
<th>+2</th>
<th>+3</th>
<th>+4</th>
<th>+5</th>
<th>+6</th>
<th>+7</th>
<th>+8</th>
<th>+9</th>
</tr>
</thead>
<tbody><tr>
<td>+0</td>
<td>\0</td>
<td>h</td>
<td>e</td>
<td>l</td>
<td>l</td>
<td>o</td>
<td>w</td>
<td>o</td>
<td>r</td>
<td>l</td>
</tr>
<tr>
<td>+10</td>
<td>d</td>
<td>\0</td>
<td>M</td>
<td>y</td>
<td>v</td>
<td>a</td>
<td>r</td>
<td>i</td>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>+20</td>
<td>l</td>
<td>e</td>
<td>\0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>那么偏移与它们对应的字符串如下表所示：</p>
<table>
<thead>
<tr>
<th>偏移</th>
<th>字符串</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>空字符串</td>
</tr>
<tr>
<td>1</td>
<td>helloworld</td>
</tr>
<tr>
<td>6</td>
<td>world</td>
</tr>
<tr>
<td>12</td>
<td>Myvariable</td>
</tr>
</tbody></table>
<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>ELF文件中的符号表往往是文件中的一个段，段名一般叫<code>.symtab</code>。符号表的结构是一个<code>Elf64_Sym</code>结构（64位ELF文件）的数组，每个<code>Elf64_Sym</code>结构对应一个符号。其结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="type">uint32_t</span>      st_name;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> st_info;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> st_other;</span><br><span class="line">   <span class="type">uint16_t</span>      st_shndx;</span><br><span class="line">   Elf64_Addr    st_value;</span><br><span class="line">   <span class="type">uint64_t</span>      st_size;</span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line"><span class="comment">// 成员变量的具体的含义可参考ELF手册，见参考资料</span></span><br></pre></td></tr></table></figure>

<p>我们可以利用<code>readelf</code>来查看ELF文件的符号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$ readelf -s SimpleSection.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">17</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS SimpleSection.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span></span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">4</span></span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span></span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">3</span> static_var<span class="number">.1802</span></span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> static_var2<span class="number">.1803</span></span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">7</span></span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">8</span></span><br><span class="line">    <span class="number">10</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">6</span></span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">3</span> global_init_var</span><br><span class="line">    <span class="number">12</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT  COM global_uninit_var</span><br><span class="line">    <span class="number">13</span>: <span class="number">0000000000000000</span>    <span class="number">36</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> func1</span><br><span class="line">    <span class="number">14</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    <span class="number">15</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND printf</span><br><span class="line">    <span class="number">16</span>: <span class="number">0000000000000024</span>    <span class="number">51</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br></pre></td></tr></table></figure>

<p><code>readelf</code>的输出格式与上面描述的<code>Elf64_Sym</code>的各个成员几乎一一对应，第一列Num表示符号表数组的下标，从0开始，共17个符号；第二列Value就是符号值，即<code>st_value</code>；第三列Size为符号大小，即<code>st_size</code>；第四列和第五列分别为符号类型和绑定信息；第六列Vis在C&#x2F;C++中未使用，第七列Ndx即<code>st_shndx</code>，表示该符号所属的段；最后一列即符号名称。对于另外的符号解释如下：</p>
<ul>
<li><code>func1</code>和<code>main</code>函数都是定义在<code>SimpleSection.c</code>里面的，它们所在的位置都为代码段，所以Ndx为1，即<code>SimpleSection.o</code>里面的<code>.text</code>。他们是函数，所以类型是<code>STT_FUNC</code>；它们是全局可见的，所以是<code>STB_GLOBAL</code>；Size表示函数指令所占的字节数；Value表示函数相对于该段起始位置的偏移量。</li>
<li><code>printf</code>这个符号在<code>SimpleSection.c</code>里面被引用，但是没有被定义。所以它的Ndx是<code>SHN_UNDEF</code>。（具体含义可参考ELF手册）</li>
<li><code>global_init_var</code>是已初始化的全局变量，它被定义在<code>.bss</code>段，即下标为3。</li>
<li><code>global_uninit_var</code>是未初始化的全局变量，它是一个<code>SHN_COMMON</code>类型的符号。</li>
<li><code>static_var.1533</code>和<code>static_var2.1534</code>是两个静态变量（符号修饰导致变量名变化），它们的绑定属性是<code>STB_LOCAL</code>，即只是编译单元内部可见。</li>
<li><code>STT_SECTION</code>类型的符号表示下标为Ndx的段的段名（符号名未显示）。</li>
<li><code>SimpleSection.c</code>表示编译单元的源文件名。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a class="link"   href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" >Executable and Linkable Format<i class="fas fa-external-link-alt"></i></a></li>
<li>《程序员的自我修养——链接、装载与库》</li>
<li><a class="link"   href="https://man7.org/linux/man-pages/man5/elf.5.html" >ELF man page<i class="fas fa-external-link-alt"></i></a></li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>链接，装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链接</title>
    <url>/2023/10/10/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>程序设计的模块化是人们一直在追求的目标，因为当一个系统十分复杂的时候，我们不得不将一个复杂的系统逐步分割成小的系统以达到各个突破的目的。一个软件亦是如此，人们把每个源代码模块独立地编译，然后按照需要将它们“组装“起来，这个组装模块的过程就是<strong>链接</strong>（Linking）。<strong>链接（Linking）</strong>本质上就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确衔接。</p>
<p>最基本的静态链接过程如下所示。每个模块的源代码文件（如<code>.c</code>）文件经过编译器编译成<strong>目标文件</strong>（Object File，一般扩展名为<code>.o</code>或<code>.obj</code>）。目标文件和 <strong>库（Library）</strong> 一起链接形成最终的可执行文件。其中，最常见的库就是<strong>运行时库（Runtime Library）</strong>，它是支持程序运行的基本函数的集合。<strong>库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成</strong>。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/5yBnPs2.png"
                      alt="Imgur"
                ></p>
<p>链接过程主要包含了三个步骤：</p>
<ol>
<li><strong>地址与空间分配（Address and Storage Allocation）</strong></li>
<li><strong>符号解析（Symbol Resolution）</strong></li>
<li><strong>重定位（Relocation）</strong></li>
</ol>
<p>下面，我们通过两个源代码文件<code>a.c</code>和&#96;b.c作为例子展开分析。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.c</span></span><br><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>b.c</code>定义了两个全局符号：一个是变量<code>shared</code>、；另一个是函数<code>swap</code>；<code>a.c</code>定义了一个全局符号：<code>main</code>。<code>a.c</code>引用了<code>b.c</code>中的<code>swap</code>和<code>shared</code>。接下来我们要将两个目标文件链接在一起并最终形成一个执行程文件<code>ab</code>。</p>
<h2 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h2><p>我们知道，可执行文件中的段是由输入的目标文件中合并而来的。那么，在链接过程的产生的第一个问题便是：<strong>对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件？</strong></p>
<h3 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h3><p>一个最简单的方案就是将输入的文件按照次序叠加起来。但是这样做的话会存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。</p>
<h3 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h3><p>其实，在实际的操作中我们会根据不同输入文件段的性质，将相同性质的段合并到一起，比如：将所有输入文件的 <strong><code>.text</code>段</strong>合并到输出文件的 <strong><code>.text</code>段</strong>，如下图所示。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/qu65c59.png"
                      alt="Imgur"
                ></p>
<p>其中**<code>.bss</code>段在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间<strong>。所以链接器在合并各个段的同时，也将<code>.bss</code>段合并，并且分配虚拟空间。此时我们可以思考一个问题，那就是这里所谓的“空间分配”到底是什么空间？事实上，此处的</strong>空间和地址**有两层含义:</p>
<ol>
<li>输出的可执行文件中的空间</li>
<li>装载后的虚拟地址中的空间</li>
</ol>
<p>对于有实际数据的段，如<code>.text</code>和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于<code>.bss</code>来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。<strong>我们在这里谈到的空间分配只关注于虚拟地址空间的分配</strong>，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。</p>
<p>现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 <strong>两步链接（Two-pass Linking）</strong> 的方法。即整个链接过程分为两步：</p>
<ul>
<li><strong>第一步 地址与空间分配</strong><br>扫描所有的输入目标文件，获得它们的各个段的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的段的长度，并将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。</li>
<li><strong>第二步 符号解析与重定位</strong><br>使用第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。</li>
</ul>
<p>我们可以使用下述的命令获取链接前后地址的分配情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -c -fno-builtin -fno-<span class="built_in">stack</span>-protector *.c</span><br><span class="line">$ ld a.o b.o -e main -o ab</span><br></pre></td></tr></table></figure>

<ul>
<li>-e main 表示将main函数作为程序入口，ld默认的程序入口为_start。</li>
<li>-o ab 表示链接输出文件名为ab，默认为a.out。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ objdump -h a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">0000002</span>e  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000006</span>e  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000006</span>e  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>a  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000006</span>e  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000098</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000098</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">$ objdump -h b.o</span><br><span class="line"></span><br><span class="line">b.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">0000004b</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000008</span>c  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000090</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>a  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000090</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000b</span>a  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c0  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">$ objdump -h ab</span><br><span class="line"></span><br><span class="line">ab:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000079</span>  <span class="number">00000000004000e8</span>  <span class="number">00000000004000e8</span>  <span class="number">000000e8</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .eh_frame     <span class="number">00000058</span>  <span class="number">0000000000400168</span>  <span class="number">0000000000400168</span>  <span class="number">00000168</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">2</span> .data         <span class="number">00000004</span>  <span class="number">0000000000601000</span>  <span class="number">0000000000601000</span>  <span class="number">00001000</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">00000029</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00001004</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>

<p>可以发现，链接前目标文件中所有段的 <strong>VMA（Virtual Memory Address）</strong> 都是0，因为虚拟空间还没有分配。链接后，可执行文件<code>ab</code>中各个段被分配到了相应的虚拟地址，如<code>.text</code>节被分配到了地址<code>00000000004000e8</code>。</p>
<p>那么，为什么链接器要将可执行文件<code>ab</code>的<code>.text</code>节分配到<code>00000000004000e8</code>？而不是从虚拟空间的0地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在Linux x86-64系统中，代码段总是从<code>0x0000000000400000</code>开始的，另外<code>.text</code>节之前还有<code>ELF Header</code>、<code>Program Header Table</code>、<code>.init</code>等占用了一定的空间，所以就被分配到了<code>00000000004000e8</code>。</p>
<h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>在分析符号解析和重定位之前，我们先来看看<code>a.o</code>中是怎么使用外部符号的，也就是说我们在<code>a.c</code>的源程序里面使用<code>shared</code>变量和<code>swap</code>函数，那么编译器将在<code>a.c</code>编译成指令时，它如何访问<code>shared</code>变量和调用<code>swap</code>函数？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ objdump -d a.o</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</span><br><span class="line">   <span class="number">0</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">   <span class="number">1</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">4</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>          	sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">8</span>:	c7 <span class="number">45</span> fc <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	movl   $<span class="number">0x64</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   f:	<span class="number">48</span> <span class="number">8</span>d <span class="number">45</span> fc          	lea    <span class="number">-0x4</span>(%rbp),%rax</span><br><span class="line">  <span class="number">13</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">35</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	lea    <span class="number">0x0</span>(%rip),%rsi        # <span class="number">1</span>a &lt;main+<span class="number">0x1a</span>&gt;</span><br><span class="line">  <span class="number">1</span>a:	<span class="number">48</span> <span class="number">89</span> c7             	mov    %rax,%rdi</span><br><span class="line">  <span class="number">1</span>d:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">22</span>:	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">27</span> &lt;main+<span class="number">0x27</span>&gt;</span><br><span class="line">  <span class="number">27</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">2</span>c:	c9                   	leaveq</span><br><span class="line">  <span class="number">2</span>d:	c3                   	retq</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序的代码里面使用的都是虚拟地址，在未进行空间分配之前main的地址为0000000000000000，等到空间分配完成后，各个函数才会确定自己在虚拟地址空间中的位置。</p>
</blockquote>
<p>从上述反汇编的结果可以看出<code>a.o</code>共定义了一个函数<code>main</code>。这个函数占用0x2d个字节，共12条指令；最左边那列是每条指令的偏移量，每一行代表一条指令。当源代码被编译成目标文件时，编译器并不知道<code>shared</code>和<code>swap</code>的地址，因为它们定义在其他目标文件中，所以编译器就暂时把地址0看作<code>shared</code>的地址，我们就看到编译器将有效地址即，0传送到指定的的寄存器（<code>13:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi</code>）。</p>
<p>另一个是偏移为<code>0x22</code>的指令的一条调用指令，它其实表示对<code>swap</code>函数的调用。这条指令共5个字节，前面的<code>0xE8</code>是操作码，后面的四个字节就是被调用函数的相对于调用指令的下一条指令的偏移量。在未重定位之前，相对偏移量被置为0。紧跟着这条<code>callq</code>指令后面的那条指令为<code>move</code>指令，<code>move</code>指令的地址为<code>0x27</code>。所以这条指令的实际调用地址为<code>0x27</code>。实际上<code>0x27</code>存放的并不是<code>swap</code>函数的地址，和前面的<code>shared</code>一样是一个假地址，真正的地址计算工作留给了链接器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ objdump -d ab</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ab:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000004000e8</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">4000e8</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">4000e9</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">  <span class="number">4000</span>ec:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>          	sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">4000f</span>0:	c7 <span class="number">45</span> fc <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	movl   $<span class="number">0x64</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">4000f</span>7:	<span class="number">48</span> <span class="number">8</span>d <span class="number">45</span> fc          	lea    <span class="number">-0x4</span>(%rbp),%rax</span><br><span class="line">  <span class="number">4000f</span>b:	<span class="number">48</span> <span class="number">8</span>d <span class="number">35</span> fe <span class="number">0</span>e <span class="number">20</span> <span class="number">00</span> 	lea    <span class="number">0x200efe</span>(%rip),%rsi        # <span class="number">601000</span> &lt;shared&gt;</span><br><span class="line">  <span class="number">400102</span>:	<span class="number">48</span> <span class="number">89</span> c7             	mov    %rax,%rdi</span><br><span class="line">  <span class="number">400105</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">40010</span>a:	e8 <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">400116</span> &lt;swap&gt;</span><br><span class="line">  <span class="number">40010f</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">400114</span>:	c9                   	leaveq</span><br><span class="line">  <span class="number">400115</span>:	c3                   	retq</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400116</span> &lt;swap&gt;:</span><br><span class="line">  <span class="number">400116</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">400117</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">  <span class="number">40011</span>a:	<span class="number">48</span> <span class="number">89</span> <span class="number">7</span>d f8          	mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">40011</span>e:	<span class="number">48</span> <span class="number">89</span> <span class="number">75</span> f0          	mov    %rsi,<span class="number">-0x10</span>(%rbp)</span><br><span class="line">  <span class="number">400122</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f8          	mov    <span class="number">-0x8</span>(%rbp),%rax</span><br><span class="line">  <span class="number">400126</span>:	<span class="number">8b</span> <span class="number">10</span>                	mov    (%rax),%edx</span><br><span class="line">  <span class="number">400128</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f0          	mov    <span class="number">-0x10</span>(%rbp),%rax</span><br><span class="line">  <span class="number">40012</span>c:	<span class="number">8b</span> <span class="number">00</span>                	mov    (%rax),%eax</span><br><span class="line">  <span class="number">40012</span>e:	<span class="number">31</span> c2                	xor    %eax,%edx</span><br><span class="line">  <span class="number">400130</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f8          	mov    <span class="number">-0x8</span>(%rbp),%rax</span><br><span class="line">  <span class="number">400134</span>:	<span class="number">89</span> <span class="number">10</span>                	mov    %edx,(%rax)</span><br><span class="line">  <span class="number">400136</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f8          	mov    <span class="number">-0x8</span>(%rbp),%rax</span><br><span class="line">  <span class="number">40013</span>a:	<span class="number">8b</span> <span class="number">10</span>                	mov    (%rax),%edx</span><br><span class="line">  <span class="number">40013</span>c:	<span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f0          	mov    <span class="number">-0x10</span>(%rbp),%rax</span><br><span class="line">  <span class="number">400140</span>:	<span class="number">8b</span> <span class="number">00</span>                	mov    (%rax),%eax</span><br><span class="line">  <span class="number">400142</span>:	<span class="number">31</span> c2                	xor    %eax,%edx</span><br><span class="line">  <span class="number">400144</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f0          	mov    <span class="number">-0x10</span>(%rbp),%rax</span><br><span class="line">  <span class="number">400148</span>:	<span class="number">89</span> <span class="number">10</span>                	mov    %edx,(%rax)</span><br><span class="line">  <span class="number">40014</span>a:	<span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f0          	mov    <span class="number">-0x10</span>(%rbp),%rax</span><br><span class="line">  <span class="number">40014</span>e:	<span class="number">8b</span> <span class="number">10</span>                	mov    (%rax),%edx</span><br><span class="line">  <span class="number">400150</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f8          	mov    <span class="number">-0x8</span>(%rbp),%rax</span><br><span class="line">  <span class="number">400154</span>:	<span class="number">8b</span> <span class="number">00</span>                	mov    (%rax),%eax</span><br><span class="line">  <span class="number">400156</span>:	<span class="number">31</span> c2                	xor    %eax,%edx</span><br><span class="line">  <span class="number">400158</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f8          	mov    <span class="number">-0x8</span>(%rbp),%rax</span><br><span class="line">  <span class="number">40015</span>c:	<span class="number">89</span> <span class="number">10</span>                	mov    %edx,(%rax)</span><br><span class="line">  <span class="number">40015</span>e:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40015f</span>:	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line">  <span class="number">400160</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>经过修正后，<code>shared</code>和<code>swap</code>的地址分别为<code>0x200efe</code>和<code>400116</code>。</p>
<h4 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h4><p>事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p>
<p>那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 <strong>重定位表（Relocation Table）</strong> 专门用来保存这些与重定位相关的信息。</p>
<p>对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应段的内容。对于每个要被重定位的ELF段都有一个对应的重定位表。如果<code>.text</code>段需要被重定位，则会有一个相对应叫<code>.rel.text</code>的段保存了代码段的重定位表；如果<code>.data</code>段需要被重定位，则会有一个相对应的<code>.rel.tdata</code>的段保存了数据段的重定位表。</p>
<p>我们可以使用objdump工具来查看目标文件中的重定位表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ objdump -r a.o</span><br><span class="line">  </span><br><span class="line">a.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line"><span class="number">0000000000000016</span> R_X86_64_PC32     shared<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000023</span> R_X86_64_PLT32    swap<span class="number">-0x0000000000000004</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到每个要被重定位的地方是一个 <strong>重定位入口（Relocation Entry）</strong>。重定位入口的偏移(Offset)表示该入口在要被重定位的段中的位置，<code>RELOCATION RECORDS FOR [.text]</code>表示这个重定位表式代码段的重定位表。对照前面反汇编结果可以知道，这里的<code>0x16</code>和<code>0x23</code>分别是代码段中<code>lea</code>和<code>callq</code>指令的地址部分。重定位表的结构也简单，它是一个<code>Elf64_Rel</code>结构的数组，每个数组元素对应一个重定位入口。<code>Elf64_Rel</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;               <span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword   r_info;                 <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;               <span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword   r_info;                 <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword  r_addend;               <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>当我们直接使用<code>ld</code>来链接<code>a.o</code>，而不链接<code>b.o</code>时。链接器就会发现<code>shared</code>和<code>swap</code>两个符号没有被定义，没办法完成链接工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ ld a.o</span><br><span class="line">ld: warning: cannot find entry symbol _start; defaulting to <span class="number">00000000004000b</span>0</span><br><span class="line">a.o: In function `main<span class="number">&#x27;</span>:</span><br><span class="line">a.c:(.text+<span class="number">0x16</span>): undefined reference to `shared<span class="number">&#x27;</span></span><br><span class="line">a.c:(.text+<span class="number">0x23</span>): undefined reference to `swap<span class="number">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其实重定位过程也伴随着符号的解析过程。重定位过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号进行重定位。</p>
<p>比如我们查看<code>a.o</code>的符号表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ readelf -s a.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">12</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span></span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">4</span></span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">6</span></span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">7</span></span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span></span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>    <span class="number">46</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> main</span><br><span class="line">     <span class="number">9</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND shared</span><br><span class="line">    <span class="number">10</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND swap</span><br></pre></td></tr></table></figure>

<p>可以看到<code>shared</code>和<code>swap</code>都是<code>UND</code>，即<code>undefined</code>未定义类型，这种未定义的符号都是因为该目标文件中有关于它们的重定位项。所以在链接器扫描完所有的输入目标文件之后，所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误。</p>
<h4 id="多重定义的全局符号解析"><a href="#多重定义的全局符号解析" class="headerlink" title="多重定义的全局符号解析"></a>多重定义的全局符号解析</h4><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p>
<p>然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。</p>
<p>另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。</p>
<p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。<strong>如果多个模块定义同名的全局符号，该如何进行取舍？</strong></p>
<p>Linux编译系统采用如下的方法解决多重定义的全局符号解析：</p>
<p><strong>在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。</strong></p>
<p>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：</p>
<ul>
<li><strong>规则1：不允许有多个同名的强符号。</strong></li>
<li><strong>规则2：如果有一个强符号和多个弱符号同名，则选择强符号。</strong></li>
<li><strong>规则3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。</strong></li>
</ul>
<p>另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：</p>
<ul>
<li><strong>情况1：两个或两个以上的强符号类型不一致。</strong></li>
<li><strong>情况2：有一个强符号，其他都是弱符号，出现类型不一致。</strong></li>
<li><strong>情况3：两个或两个以上弱符号类型不一致。</strong></li>
</ul>
<p>其中，情况1由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 <strong>COMMON块（Common Block ）</strong> 的机制来处理。其过程如下：</p>
<p><strong>首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况3，最终链接时选择最大的类型。对于情况2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。</strong></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a class="link"   href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" >Executable and Linkable Format<i class="fas fa-external-link-alt"></i></a></li>
<li>《程序员的自我修养——链接、装载与库》</li>
<li><a class="link"   href="https://man7.org/linux/man-pages/man5/elf.5.html" >ELF man page<i class="fas fa-external-link-alt"></i></a></li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>链接，装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解C++对象模型(二)</title>
    <url>/2024/04/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="构造函数语义学"><a href="#构造函数语义学" class="headerlink" title="构造函数语义学"></a>构造函数语义学</h1><h2 id="一、默认构造函数的构造操作"><a href="#一、默认构造函数的构造操作" class="headerlink" title="一、默认构造函数的构造操作"></a>一、默认构造函数的构造操作</h2><p>C++中对于默认构造函数的解释是：<strong>默认的构造函数会在需要的时候被编译器产生出来</strong>。如下述实例所示，正确的程序语意要求<code>Foo</code>有一个默认构造函数，可以将它的两个成员初始化为0。那上述实例会合成出一个默认构造函数吗？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Foo *pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Foo bar;</span><br><span class="line">  <span class="keyword">if</span> (bar.val || bar.pnext)</span><br><span class="line">    <span class="comment">// ... do sth</span></span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实并不会！默认构造函数的合成关键是在于谁需要？是程序的需要还是编译器的需要？如果是程序的需要，那初始化便是程序员的责任。而上述例子便是程序员的责任，因此程序并不会合成一个默认构造函数。那么，什么时候编译器才会合成一个默认构造函数呢？ </p>
<ul>
<li><strong>当编译器需要默认构造函数的时候才会合成出一个默认构造函数!</strong> 且被合成出来的构造函数只执行编译器所需的行动。这样合成的默认构造函数是<code>notrivial</code>的，并且这个产生操作只有在默认构造函数真正被调用时才会进行合成。</li>
<li>如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是<code>trivial</code>的。<strong>需要注意<code>trivial</code>构造函数只存在于概念上，编译器实际上根本不会去合成出来</strong>（此类构造函数不做任何有意义的事情，所以编译器不去合成它）。</li>
</ul>
<h3 id="1-1-什么时候下会合成默认构造函数？"><a href="#1-1-什么时候下会合成默认构造函数？" class="headerlink" title="1.1 什么时候下会合成默认构造函数？"></a>1.1 什么时候下会合成默认构造函数？</h3><p>通常编译器会在以下四种情况会合成<code>notrivial</code>的默认构造函数。</p>
<h4 id="1-1-1-具有默认构造函数的成员类对象"><a href="#1-1-1-具有默认构造函数的成员类对象" class="headerlink" title="1.1.1 具有默认构造函数的成员类对象"></a>1.1.1 <strong>具有默认构造函数的成员类对象</strong></h4><ul>
<li>类没有任何构造函数，但它内含一个含有默认构造函数的成员类，那么这个类的<code>implicit</code>默认构造函数就是<code>nontrivial</code>， 编译器需要为该类合成出 一个默认构造函数。</li>
</ul>
<p>考虑下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; <span class="keyword">public</span>: <span class="built_in">Foo</span>(), <span class="built_in">Foo</span>(<span class="type">int</span>) ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; <span class="keyword">public</span>: Foo foo; <span class="type">char</span> *str; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Bar bar; <span class="comment">// Bar::foo must be initialized here</span></span><br><span class="line">  <span class="keyword">if</span> (str) &#123;&#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被合成的<code>Bar</code>默认构造函数内含必要的代码，使其能够调用类 <code>Foo</code> 的默认构造函数来处理成员对象 <code>Bar::bar</code>，但它并不产生任何代码来初始化Bar::str。被合成的默认构造函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Bar::bar</span><span class="params">()</span> </span>&#123; foo.Foo::<span class="built_in">Foo</span>();&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个有趣的问题：类声明头文件可以被许多源文件所包含，如何避免合成默认构造函数、拷贝构造函数、析构函数、 赋值拷贝操作符(4 大成员函数)时不引起函数的重定义?<br>解决方法是以 inline 的方式完成（一个inline函数有静态链接，不会被文件以外者看到），如果函数太复杂不适合 inline，就会合成一个 explicit non-inline static 实例 (Static 函数独立于编译单元)</p>
</blockquote>
<ul>
<li>如果类 <code>A</code> 内含一个或一个以上的成员类对象，那么类 <code>A</code> 的每一个构造函数必须调用每一个成员类的默认构造函数。<code>C++</code> 要求以成员对象在类中的声明顺序来调用各个构造函数。这一点由编译器完成，它为每一个构造函数安插程序代码，以“成员声明顺序”调用每一个成员所关联的默认构造函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dopey</span> &#123; <span class="keyword">public</span>: Dopey; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneezy</span> &#123; <span class="keyword">public</span>: <span class="built_in">Sneezy</span>(<span class="type">int</span>); <span class="built_in">Sneezy</span>(); ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bashful</span> &#123; <span class="keyword">public</span>: <span class="built_in">Bashful</span>(); ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snow_White</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Dopey dopey;</span><br><span class="line">  Sneezy sneezy;</span><br><span class="line">  Bashful bashful;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> mumble;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Snow_White未定义默认构造函数，就会有一个nontrivial构造函数</span></span><br><span class="line"><span class="comment">// 被合成出来，依次调用Dopey、Sneezy、Bashful的默认构造函数。</span></span><br><span class="line">Snow_White::<span class="built_in">Snow_white</span>()</span><br><span class="line">&#123;</span><br><span class="line">  dopey.Dopey::<span class="built_in">Dopey</span>();</span><br><span class="line">  sneezy.Sneezy::<span class="built_in">Sneezy</span>();</span><br><span class="line">  bashful.Bashful::<span class="built_in">Bashful</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果Snow_White定义了默认构造函数，就会有下述nontrivial构造函数被合成出来。</span></span><br><span class="line"><span class="comment">// 已定义构造函数</span></span><br><span class="line">Snow_White::<span class="built_in">Snow_white</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123; </span><br><span class="line">  mumble = <span class="number">2048</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码扩张后</span></span><br><span class="line">Snow_White::<span class="built_in">Snow_white</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">  dopey.Dopey::<span class="built_in">Dopey</span>();</span><br><span class="line">  sneezy.Sneezy::<span class="built_in">Sneezy</span>(<span class="number">1024</span>);</span><br><span class="line">  bashful.Bashful::<span class="built_in">Bashful</span>();</span><br><span class="line">  </span><br><span class="line">  mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-带有默认构造函数的基类"><a href="#1-1-2-带有默认构造函数的基类" class="headerlink" title="1.1.2 带有默认构造函数的基类"></a>1.1.2 带有默认构造函数的基类</h4><p>如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，那么这个派生类的默认构造函数会被视为 <code>nontrivial</code> ，并且这个默认构造函数会被按照基类的声明顺序调用基类的默认构造函数合成出来。</p>
<p>如果设计者提供多个构造函数，但其中都没有默认构造函数的话，<strong>编译器会扩张现有的每一个构造函数</strong>，将用以调用所有必要的默认构造函数的程序代码加进去。(它不会合成 一个新的默认构造函数)。</p>
<h4 id="1-1-3-带有虚函数的类"><a href="#1-1-3-带有虚函数的类" class="headerlink" title="1.1.3 带有虚函数的类"></a>1.1.3 带有虚函数的类</h4><p>有两种情况需要合成出默认构造函数：</p>
<ul>
<li>类声明(或继承)一个虚函数。</li>
<li>类派生自一个继承串链，其中有一个或者更多的虚基类。</li>
</ul>
<p>不管哪一种情况，由于缺乏用户声明的构造函数，编译器会详细记录合成一个默认构造函数的必要信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span> </span>&#123; widget.<span class="built_in">flip</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设Bell和Whistle都派生自Widget</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Bell b;</span><br><span class="line">  Whistle w;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">flip</span>(b);</span><br><span class="line">  <span class="built_in">flip</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于含有虚函数，其扩张行动会发生在编译期间：</p>
<ul>
<li>编译器会产生一个虚表vtbl，其内放置类的虚函数地址。</li>
<li>每一个类对象中，编译器会额外的合成一个指针成员vptr指向与之相关的类虚表vtbl。</li>
</ul>
<p>此外，widget.flip()的虚拟调用操作(virtual invocation)会被重新改写，以使用 widget 的 vptr 和 vtbl 中的 flip 条目：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// widget.flip()的虚拟调用操作(virtual invocation)</span></span><br><span class="line">(*widget.vptr[<span class="number">1</span>])(&amp;widget)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1表示flip()在 virtual table 中的固定索引;</span></span><br><span class="line"><span class="comment">// &amp;widget 代表要交给被调用的某个flip()实例的this指针</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了让这个机制生效，编译器必须为每一个Widget(或其派生类) 对象的 vptr 设定初值，放置适当的virtual table地址。</p>
</blockquote>
<h4 id="1-1-4-带有虚基类的类"><a href="#1-1-4-带有虚基类的类" class="headerlink" title="1.1.4 带有虚基类的类"></a>1.1.4 带有虚基类的类</h4><p>虚基类的实现法在不同的编译器之间有极大的差异。然而，每一种<br>实现法的共同点在于必须使虚基类在其每一个派生类对象中的位置，能够于执行期准备妥当。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; <span class="keyword">public</span>: <span class="type">int</span> j; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; <span class="keyword">public</span>: <span class="type">double</span> d; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; <span class="keyword">public</span>: <span class="type">int</span> k; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译期决定pa-&gt;X::i的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">  <span class="built_in">foo</span>(<span class="keyword">new</span> C);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能的编译器转变操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span> </span>&#123; pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>编译器无法固定住 <code>foo()</code> 之中“经由 <code>pa</code> 而存取的 <code>X::i</code> 的实际偏移位置，因为 <code>pa</code> 的真正类型可以改变。编译器必须改变执行存取操作的那些代码，使 <code>X::i</code> 可以延迟至执行期才决定下来。</p>
<p> __ vbcX (或编译器所做出的某个什么东西) 是在类对象构造期间被完成的。对于类所定义的每一个构造函数，编译器会安插那些 “允许每一个虚基类的执行期存取操作” 的代码。如果类没有声明任何构造函数，编译器必须为它合成一个默认的构造函数。</p>
<p>被合成出来的构造函数只能满足编译器的需要，通过下属两种方法：</p>
<ul>
<li>通过调用成员对象或基类的默认构造函数；</li>
<li>为每一个对象初始化其虚函数机制或虚基类机制。</li>
</ul>
<p><strong>C++新手常见的2个误区:</strong></p>
<ul>
<li><p><font color=red><strong>ERROR:</strong></font> 如果类没有定义默认构造函数就会被合成一个。首先定义了其它的构造函数就不会合成默认构造函数；再次即使没有定义任何构造函数也不一定会合成默认构造函数，可能仅仅是概念上有，但实际上不合成出来。</p>
</li>
<li><p><font color=red><strong>ERROR:</strong></font>  编译器合成出来的默认构造函数会显式设定类内每一个数据成员的默认值。明显不会，区分了全局对象，栈对象、堆对象 就非常明白了只有在全局上的对象会被清 0，其它的情况都不会保证被清 0。</p>
</li>
</ul>
<h2 id="二、拷贝构造函数的构造操作"><a href="#二、拷贝构造函数的构造操作" class="headerlink" title="二、拷贝构造函数的构造操作"></a>二、拷贝构造函数的构造操作</h2><p>拷贝构造函数和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的类来说，拷贝构造函数仅仅需要按位拷贝就可以。当然，满足 <code>bitwise copy semantics</code> 的拷贝构造函数是 <code>trivial</code> 的，不会真正被合成出来，与默认构造函数一样，只有 <code>nontrivial</code> 的拷贝构造函数才会被真正合成出来。</p>
<h4 id="2-1-什么时候一个类不展现bitwise-copy-semantics呢？"><a href="#2-1-什么时候一个类不展现bitwise-copy-semantics呢？" class="headerlink" title="2.1 什么时候一个类不展现bitwise copy semantics呢？"></a>2.1 什么时候一个类不展现bitwise copy semantics呢？</h4><p>分为四种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。</p>
<ol>
<li>当类内含一个成员对象而后者声明了(也可能由于 <code>nontrivial</code> 语意从而编译器真正合成出来的)一个拷贝构造函数时。</li>
<li>当类继承自一个基类，而后者存在一个拷贝构造函数时(不论是被显式声明或是被合成而得)。</li>
<li>当类声明了一个或多个虚函数时。</li>
<li>当类派生自一个继承串链，其中有一个或多个虚基类时。</li>
</ol>
<h5 id="2-1-1-重新设定虚表的指针"><a href="#2-1-1-重新设定虚表的指针" class="headerlink" title="2.1.1 重新设定虚表的指针"></a>2.1.1 重新设定虚表的指针</h5><p>对于每一个新产生的类对象，如果编译器不能成功而正确的设置好其 <code>vptr</code> 的初值，将会导致可怕的后果。因此当编译器导入一个 <code>vptr</code> 到类中时，该类就不再展现 <code>bitwise</code> 语意了。</p>
<p>考虑下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ZooAnimal</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ZooAnimal的animate()和draw()</span></span><br><span class="line">  <span class="comment">// 所需要的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Bear</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>; <span class="comment">// 虽未明写virtual，但它其实是virtual</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;    <span class="comment">// 虽未明写virtual，但它其实是virtual</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Bear的animate()、dance()和draw()</span></span><br><span class="line">  <span class="comment">// 所需要的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ZooAnimal</code> 类对象以另一个 <code>ZooAnimal</code> 类对象作为初值，或 <code>Bear</code> 类对象以另一个 <code>Bear</code> 类对象作为初值，都可以直接靠 <code>bitwise copy semantics</code> 完成。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bear yogi;</span><br><span class="line">Bear winnie = yogi;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic.imgdb.cn/item/662088550ea9cb1403aed05c.png"
                      alt="bitwise copy semantics"
                ></p>
<p><code>yogi</code> 会被默认的 <code>Bear</code> 构造函数初始化。<code>yogi</code> 的 <code>vptr</code> 被设定指向 <code>Bear</code> 的虚表。因此，把<code>yogi</code> 的 <code>vptr</code> 值拷贝给 <code>winnie</code> 的 <code>vptr</code> 是安全的。</p>
<ul>
<li>类对象以其派生类的对象内容做初始化操作时，其 <code>vptr</code> 复制操作也必须保证安全。<code>franny</code> 的 <code>vptr</code> 不可以被设定指向 <code>Bear</code> 的虚表。否则当下面程序片段中的 <code>draw()</code> 被调用而<code>franny</code> 被传进去时，就会出问题：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bear yogi;</span><br><span class="line">ZooAnimal franny = yogi; <span class="comment">// 注意此处会发生切割行为</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">const</span> ZooAnimal&amp; zoey)</span> </span>&#123; zoey.<span class="built_in">draw</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// franny的vptr指向ZooAnimal的虚表而非Bear的虚表</span></span><br><span class="line">  ZooAnimal franny = yogi;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">draw</span>(yogi);   <span class="comment">// 调用Bear::draw()</span></span><br><span class="line">  <span class="built_in">draw</span>(franny); <span class="comment">// 调用ZooAnimal::draw()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic.imgdb.cn/item/6620895f0ea9cb1403b54944.png"
                      alt="non-bitwise copy semantices"
                ></p>
<p>也就是说，合成出来的<code>ZooAnimal</code> 拷贝构造函数会显式设定对象的 <code>vptr</code> 指向 <code>ZooAnimal</code>  类的虚表而不是直接从右手边的类对象中将其 <code>vptr</code> 现值拷贝过来。</p>
<h5 id="2-1-2-虚基类子对象"><a href="#2-1-2-虚基类子对象" class="headerlink" title="2.1.2 虚基类子对象"></a>2.1.2 虚基类子对象</h5><p>虚基类的存在需要特别处理。一个类对象如果以另一个对象作为初值，而后者有一个虚基类子对象，那么也会使 <code>bitwise copy semantics</code> 失效。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Raccoon</span>() &#123;<span class="comment">/*设定私有数据初值*/</span>&#125;</span><br><span class="line">  <span class="built_in">Raccoon</span>( <span class="type">int</span> val ) &#123;<span class="comment">/*设定私有数据初值*/</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 所有必要的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedPanda</span> : <span class="keyword">public</span> Raccoon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RedPanda</span>() &#123;<span class="comment">/*设定私有数据初值*/</span>&#125;</span><br><span class="line">  <span class="built_in">RedPanda</span>( <span class="type">int</span> val ) &#123;<span class="comment">/*设定私有数据初值*/</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 所有必要的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的bitwise copy还不够，编译器必须显式地将</span></span><br><span class="line"><span class="comment">// little_critter的虚基类pointer/offset初始化</span></span><br><span class="line">RedPanda little_red;</span><br><span class="line">Raccoon little_critter = little_red;</span><br></pre></td></tr></table></figure>

<p>在上述情况下，为了完成正确的 <code>little_red</code> 初值设定，编译器必须合成一个拷贝构造函数，安插一些代码以设定虚基类pointer&#x2F;offset 初值，对每一个成员执行必要的 <code>memberwise</code>初始化操作，以及执行其他的内存相关工作。</p>
<p>在下面的情况，编译器无法知道 <code>bitwise copy semantics</code> 是否还保持着，因为它无法知道 <code>Raccoon</code> 指针是否指向一个真正的 <code>Raccoon</code> 对象或者指向一个派生类对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Raccoon *ptr;</span><br><span class="line">Raccoon little_critter = *ptr;</span><br></pre></td></tr></table></figure>

<h2 id="三、程序转化语义学"><a href="#三、程序转化语义学" class="headerlink" title="三、程序转化语义学"></a>三、程序转化语义学</h2><p>本部分是讨论编译器调用拷贝构造函数时的策略(如何优化以提高效率)，或者说是是关于编译器对于程序是如何进行有效转化或者说翻译，以实现C++的语法机制。主要有以下的几种语意：</p>
<h4 id="3-1-显式初始化操作"><a href="#3-1-显式初始化操作" class="headerlink" title="3.1 显式初始化操作"></a>3.1 显式初始化操作</h4><p>可以考虑如下的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X x0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;</span><br><span class="line">  X x2 = x0;</span><br><span class="line">  X x3 = <span class="built_in">X</span>(x0);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必要的程序转化需要两个阶段：</span></span><br><span class="line"><span class="comment">// 1. 重写每一个定义，但不会执行初始化操作。</span></span><br><span class="line"><span class="comment">// 2. 安插类的拷贝构造函数调用操作。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;</span><br><span class="line">  X x2 = x0;</span><br><span class="line">  X x3 = <span class="built_in">X</span>(x0);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 编译器安插X的拷贝构造函数的调用操作</span></span><br><span class="line">  x1.X::<span class="built_in">X</span>(x0);</span><br><span class="line">  x2.X::<span class="built_in">X</span>(x0);</span><br><span class="line">  x3.X::<span class="built_in">X</span>(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-参数的初始化"><a href="#3-2-参数的初始化" class="headerlink" title="3.2 参数的初始化"></a>3.2 参数的初始化</h4><p>C++标准(8.5节)说，把一个类对象当做参数传递给一个函数或者把它作为一个函数的返回值时，相当于以下形式的初始化操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中xx是形式参数或者返回值，arg代表真正的参数值。</span></span><br><span class="line">X xx = arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若已知下面的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X x0)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若采用下述的调用方式，将会使得局部实例x0以 memberwise 的形式以实际参数为初始值进行初始化</span></span><br><span class="line">X xx;</span><br><span class="line"><span class="built_in">foo</span>(xx);</span><br></pre></td></tr></table></figure>

<p>一般来说，编译器有两种做法：</p>
<ul>
<li>引入一个临时性对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 编译器生成一个临时性对象</span></span><br><span class="line">X __temp0;</span><br><span class="line"><span class="comment">// 2. 编译器对拷贝构造函数的调用</span></span><br><span class="line">__temp0.X::<span class="built_in">X</span>(xx);</span><br><span class="line"><span class="comment">// 3. 重新改写函数调用操作;</span></span><br><span class="line"><span class="built_in">foo</span>(__temp0);</span><br><span class="line"><span class="comment">// 4. 修改参数调用方式为引用，否则如何工作又回到原点啦(临时性对象以类X的拷贝构造函数正确的设定初值，然后以bitwise的方式拷贝到x0这个局部实例中)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X &amp;x0)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>采用“拷贝构建”的方式，将参数直接以拷贝构造函数建构到函数的堆栈上。</li>
</ul>
<h4 id="3-3-返回值的初始化"><a href="#3-3-返回值的初始化" class="headerlink" title="3.3 返回值的初始化"></a>3.3 返回值的初始化</h4><p>当返回值是对象时，这个对象是如何返回的呢？<code>cfront</code> 使用的是一个双阶段转化：</p>
<ul>
<li>首先加上一个额外的参数，是类对象的引用，这个参数将放置通过拷贝构建得来的返回值。</li>
<li>在<code>return</code> 之前安插一个拷贝构建函数的调用操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X xx;</span><br><span class="line">  <span class="comment">// 处理xx ...</span></span><br><span class="line">  <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar()转换</span></span><br><span class="line"><span class="comment">//安插了临时引用参数__result</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(X &amp; __result)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X xx;</span><br><span class="line">  <span class="comment">// 默认构造函数调用</span></span><br><span class="line">  xx.X::<span class="built_in">X</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理xx...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 拷贝构造函数调用操作</span></span><br><span class="line">  __result.X::<span class="built_in">X</span>(xx);  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、成员初始化列表"><a href="#四、成员初始化列表" class="headerlink" title="四、成员初始化列表"></a>四、成员初始化列表</h2><p>当我们写下一个构造函数时，就有机会设定类成员的初值。要不是由成员初始化列表，就是在构造函数函数体之内。除了4种情况，你的任何选择其实都差不多。</p>
<h4 id="4-1-初始化列表内部的真正操作是什么？"><a href="#4-1-初始化列表内部的真正操作是什么？" class="headerlink" title="4.1 初始化列表内部的真正操作是什么？"></a>4.1 初始化列表内部的真正操作是什么？</h4><p>为了让你的程序能够顺利被编译，你必须使用成员列表初始化：</p>
<ul>
<li>当初始化一个 <code>reference member</code> 时；</li>
<li>当初始化一个 <code> const member</code> 时；</li>
<li>当调用一个基类的构造函数，而它拥有一组参数时；</li>
<li>当调用一个成员类的构造函数，而它拥有一组参数时；</li>
</ul>
<p>在这4种情况下，程序可以被正确编译并执行，但是效率不高。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span> &#123;</span><br><span class="line">  String _name;</span><br><span class="line">  <span class="type">int</span>    _cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Word</span>() &#123;</span><br><span class="line">    _name = <span class="number">0</span>;</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里 Word 构造函数会产生一个临时性的 String 对象，然后将它初始化，之后以一个赋值运算符将临时性的对象指定给 _name，随后再摧毁那个临时性的对象。</span></span><br><span class="line"><span class="comment">// 构造函数内部扩张结果</span></span><br><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line">Word::<span class="built_in">Word</span>(<span class="comment">/* this pointer goes here*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 调用 String 的默认构造函数</span></span><br><span class="line">  _name.String::<span class="built_in">String</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 产生临时性对象</span></span><br><span class="line">  String temp = <span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// memberwise 地拷贝 _name</span></span><br><span class="line">  _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 摧毁临时性对象</span></span><br><span class="line">  temp.String::~<span class="built_in">String</span>();</span><br><span class="line">  </span><br><span class="line">  _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更明显有效率的实现方法是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 较佳的方式</span></span><br><span class="line">Word::Word : _name(<span class="number">0</span>) &#123; _cnt = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩张后</span></span><br><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line">Word::<span class="built_in">Word</span>(<span class="comment">/* this pointer goes here*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 调用 String(int) 构造函数</span></span><br><span class="line">  _name.String::<span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">  _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-成员列表初始化中会发生什么？"><a href="#4-1-1-成员列表初始化中会发生什么？" class="headerlink" title="4.1.1 成员列表初始化中会发生什么？"></a>4.1.1 成员列表初始化中会发生什么？</h4><p>编译器会一一操作列表初始化，以适当顺序在构造函数之内安插初始化操作，并且在任何显式用户代码之前。<strong>且需要注意：列表中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表中的排列顺序决定的。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于声明顺序的缘故，成员列表初始化中的 i(j) 其实比 j(val) 更早执行。但因为j一开始未有初值，所以i(j)的执行结果导致i无法预知其值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val), <span class="built_in">i</span>(j) &#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较受到喜爱的方式</span></span><br><span class="line">X::<span class="built_in">X</span>(<span class="type">int</span> val)</span><br><span class="line">  :<span class="built_in">j</span>(val)</span><br><span class="line">&#123; i = j; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外一个常见的问题是，调用一个成员函数设定一个成员的初值</span></span><br><span class="line"><span class="comment">// X::xfoo()被调用，这样好吗？</span></span><br><span class="line">X::<span class="built_in">X</span>(<span class="type">int</span> val)</span><br><span class="line">  : <span class="built_in">i</span>(<span class="built_in">xfoo</span>(val)), <span class="built_in">j</span>(val)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 你并不知道xfoo()对X对象的依赖性有多高，如果xfoo()放到构造函数体内，那么对于“到底是哪一个成员在xfoo()执行时被设立初值”这件事，就可以确保不会发生模棱两可的情况。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>深入理解对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解C++对象模型(一)</title>
    <url>/2024/04/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="第一章：关于对象"><a href="#第一章：关于对象" class="headerlink" title="第一章：关于对象"></a>第一章：关于对象</h1><p>在C语言中，“数据” 和“处理数据的操作 (函数)” 是分开来声明的，也就是说，语言本身并没有支持“数据和函数” 之间的关联性。我们把这种程序方法称为程序性的(procedural)，由一组 “分布在各个以功能为导向的函数中” 的算 法所驱动，它们处理的是共同的外部数据。举个例子，如果我们声明一个<code>struct Point3d</code>，像这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">  <span class="type">float</span> z;</span><br><span class="line">&#125; Point3d;</span><br></pre></td></tr></table></figure>

<p>但当我们想打印<code>Point3d</code>这个数据结构时，我们就得定义一个像这样的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Point3d_print</span><span class="params">(<span class="type">const</span> Point3d *pd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(%g, %g, %g)&quot;</span>, pd-&gt;x, pd-&gt;y, pd-&gt;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者定义一个宏，抑或是直接在函数中完成打印操作，也可以经由一个前置处理宏来完成。</p>
</blockquote>
<p>而在C++中，*<code>Point3d</code>* 有可能采用独立的“抽象数据类型(abstract data type, ADT)” 来实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Point3d</span>(<span class="type">float</span> x = <span class="number">0.0</span>, <span class="type">float</span> y = <span class="number">0.0</span>, <span class="type">float</span> z = <span class="number">0.0</span>) : _x(x), _y(y), _z(z) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _x; &#125;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _y; &#125;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _z; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">x</span><span class="params">(<span class="type">float</span> xval)</span> </span>&#123; _x = xval; &#125;</span><br><span class="line">  <span class="comment">// ... etc ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">float</span> _x;</span><br><span class="line">  <span class="type">float</span> _y;</span><br><span class="line">  <span class="type">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ostream&amp;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt; (ostream &amp;os, <span class="type">const</span> Point3d &amp;pt)</span><br><span class="line">&#123;</span><br><span class="line">  os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pt.<span class="built_in">x</span>() &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">     &lt;&lt; pt.<span class="built_in">y</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pt.<span class="built_in">z</span>() &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很明显，C和C++不只在程序风格上有显著的不同，在程序的思考上也有明显的差异。</p>
<h2 id="加上封装后的布局成本"><a href="#加上封装后的布局成本" class="headerlink" title="加上封装后的布局成本"></a>加上封装后的布局成本</h2><p>当我们将<code>Point3d</code>转换到C++之后，第一个可能想到的问题就是:<strong>加上了封裝之后，程序的布局成本是否增加了?</strong> 答案是<code>class Point3d</code> 并<strong>没有增加成本</strong>。这是因为：</p>
<ul>
<li>三个 data merabers 直接内含在每一个class object 之中，就像C struct 的情况一样。</li>
<li>而member functions虽然含在class的声明之内，却不出现在object 之中。</li>
<li>每一个non-inline member function 只会诞生一个函数实例。至于每一个“拥有零个或一个定义” 的inline function 则会在其每一个使用者 (模块) 身上产生一个函数实例。</li>
</ul>
<p><strong><code>Point3d</code>支持封装这一点并未带给它任何额外的成本。</strong>而且C++在布局以及存取时间上主要的额外负担是由virtual 引起的：</p>
<ul>
<li>virtual function 机制：保存vtable和通过vtable找到函数地址。</li>
<li>virtual base class 机制：通过指针来找到基类的成员。</li>
</ul>
<h2 id="1-1-C-对象模型"><a href="#1-1-C-对象模型" class="headerlink" title="1.1 C++对象模型"></a>1.1 C++对象模型</h2><p>在C++中有：</p>
<ul>
<li><strong>两种类数据成员：static 和 nonstatic</strong></li>
<li><strong>三种类成员函数：static 、nonstatic 和 virtual</strong>。</li>
</ul>
<p>下面我们通过class <code>Point</code>来看一下，在机器中类是如何模塑 (modeling) 出各种data members 和function members 的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Point</span>(<span class="type">float</span> xval);</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">float</span> _x;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> _point_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-1-简单对象模型"><a href="#1-1-1-简单对象模型" class="headerlink" title="1.1.1 简单对象模型"></a>1.1.1 简单对象模型</h3><p>在简单模型中，一个对象由一系列的 slots 构成，每一个 slot 指向一个 members。Members 按其声明顺序，各被指定一个 slot。每一个 data member 或 function member 都有自己的一个slot。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic.imgdb.cn/item/66208aac0ea9cb1403bd9dc9.png"
                      alt="SimpleObjectModel"
                ></p>
<p>在这个简单模型下，members 本身并不放在对象内，只有“指向member 的指针” 才放在对象内（避免了“members 有<strong>不同的类型，因而需要不同的存储空间</strong>” 的问题）。对象中的 members 是通过 slot 的索引值来寻址的，本例之中_x的索引是6，_point_counrt 的索引是7。</p>
<p>需要注意这个模型并没有被应用于实际产品上，不过关于<strong>索引或 slot 个数的观念，</strong> 倒是被应用到C++的“指向成员的指针” (pointer-to-member)观念之中。</p>
<h3 id="1-1-2-表格驱动对象模型"><a href="#1-1-2-表格驱动对象模型" class="headerlink" title="1.1.2 表格驱动对象模型"></a>1.1.2 表格驱动对象模型</h3><p>如果对所有类中所有对象都有一致的表达方式的话，就可以采用下面的模型。该对象模型把所有与members 相关的信息抽出来，放在一个 <strong>data member table</strong> 和一个 <strong>member functiontable</strong> 之中，class object 本身则内含指向这两个表格的指针。Member function table 是一系列的 slots，每一个slot 指向一个member function；Data member table 则直接持有 data 本身。(<strong>没有实际应用于真正的 C++ 编译器身上</strong>，但 member function table 这个观念却成为支持virtual functions的一个有效方案)</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic.imgdb.cn/item/66208aac0ea9cb1403bda15c.png"
                      alt="MemberTableModel"
                ></p>
<h3 id="1-1-3-C-对象模型"><a href="#1-1-3-C-对象模型" class="headerlink" title="1.1.3 C++对象模型"></a>1.1.3 C++对象模型</h3><p>前两个模型有两个主要问题：引入的指针过多，空间浪费严重；另一个则是添加的索引层次过多，导致数据存取性能较低。C++对象模型是从简单对象模型派生而来，并对内存空间和存取时间做了优化。在此模型下：</p>
<ul>
<li>Nonstatic data members 放在每一个类对象之内；</li>
<li>static data members 存放在类对象之外；</li>
<li>Static和nonstatic function members 也被放在类对象之外。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic.imgdb.cn/item/66208ab80ea9cb1403bdf13d.png"
                      alt="C++ObjectModel"
                ></p>
<ul>
<li>虚函数机制则由以下的 2 个的两个步骤来支持:<ul>
<li>每一个class会产生一个虚表(vtbl, vtable)，虚表中存放着一系列指向虚函数的指针;</li>
<li>每一个class 对象内添加一个指针vptr，指向相对应的vtable。vptr的设定与重置由每一个class的构造函数、析构函数和拷贝赋值运算符自动完成。</li>
<li>通常每一个 class 所关联的 <strong>type_info</strong> 对象的指针保存在<strong>vtable</strong> 的第一个 <strong>slot</strong> 中，用于支持RTTI (runtime type identification)</li>
</ul>
</li>
<li>需要清楚的明白一点是: <strong>一个 vtable 对应一个 class，一个 vptr 才对应一个 class object</strong>，必须区分开这 2 个概念。</li>
</ul>
<h2 id="1-2-关键词所带来的差异"><a href="#1-2-关键词所带来的差异" class="headerlink" title="1.2 关键词所带来的差异"></a>1.2 关键词所带来的差异</h2><ul>
<li><p>C++优先判断一个语句为声明: 当语言无法区分一个语句是声明还是表达式时，就需用用一个超越语言范围的规则。</p>
</li>
<li><p>struct 和 class 关键字的意义:</p>
<ul>
<li><p>它们之间在语言层面并无本质的区别，更多的是概念和编程思想上的区别。</p>
</li>
<li><p>struct 用来表现那些只有数据的集合体 POD(Plain OI’ Data)、而 class 则希望表达的</p>
<p>是 ADT(abstract data type)的思想;</p>
</li>
<li><p>由于这2个关键字在本质是无区别，所以class并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学;</p>
</li>
<li><p>由于这2个关键字在本质是无区别，所以class并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学;</p>
</li>
</ul>
</li>
<li><p>C++只保证处于同一个 access section 的数据，一定会以声明的次序出现在内存布局当中。 C++标准只提供了这一点点的保证。</p>
</li>
<li><p>与 C 兼容的内存布局: 组合，而非继承，才是把 C 和 C++结合在一起的唯一可行的方法。 只有使用组合时，才能够保证与 C 拥有相同的内存布局，使用继承时的内存布局是不受 C++ Standard 所保证的(很多编译器也可行，但是标准未定义!)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C_point</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">C_point</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _c_point; &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  C_point _c_point;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-3-对象的差异"><a href="#1-3-对象的差异" class="headerlink" title="1.3 对象的差异"></a>1.3 对象的差异</h2><p>C++程序设计模型直接支持三种programming paradigms。</p>
<ul>
<li>程序模型 (procedural model): 就像C一样，一条语句接一条语句的执行或者函数跳转;</li>
<li>抽象数据类型模型 (abstract data type model, ADT): 此模型所谓的“抽象”是和一组表达式(public 接口) 一起提供的，那时其运算定义仍然隐而未明;</li>
<li>面向对象模型 (object-oriented model): 在此模型中有一些彼此相关的类型，通过一个抽象的base class (用以提供共同接口)被封装起来 。C++ 通过class 的pointers和references来支持多态，这种程序设计风格就称为“面向对象” 。</li>
</ul>
<blockquote>
<p>虽然你可以直接或间接处理继承体系中的一个base class object，<strong>但只有通过 pointer 或reference 的间接处理，才支持OO程序设计所需的多态性质</strong>。</p>
</blockquote>
<p>在C++，多态只存在于一个个的public class 体系中。举个例子，px可能指向某个类型的object，或指向根据public 继承关系派生而来的一个子类型。Nonpublic 的派生行为以及类型为void*的指针可以说是多态的，但它们并没有被语言明确地支持，也就是说它们必须由程序员通过显式的转换操作来管理。</p>
<p>C++以下列方式支持多态</p>
<ul>
<li><p>经由一组隐式的转化操作。例如把一个derived class指针转化为一个指向其public base type的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shape *ps = <span class="keyword">new</span> <span class="built_in">circle</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>经由virtual function 机制：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps-&gt;<span class="built_in">rotate</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>经由dynamic_cast和typeid运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (circle *pc = <span class="built_in">dynamic_cast</span>&lt;circle*&gt;(ps)) ...</span><br></pre></td></tr></table></figure></li>
</ul>
<p>多态的主要用途是经由一个共同的接又来影响类型的封装，这个接又通常被定义在一个抽象的base class 中。例如Library_materials class就为Book、ridea、 Pupper 等 subtype 定义了一个接口。这个共享接口是以virtual function 机制引发的， 它可以在执行期根据object 的真正类型解析出到底是哪一个西数实例被调用。</p>
<p>需要多少内存才能够表现一个claso bject ?一般而言要有:</p>
<ul>
<li>其nonstatic data members 的总和大小；</li>
<li>加上任何由于位对齐 (alignment) 的需求而填补(padding) 上去的空间(可能存在于 members 之间，也可能存在于集合体边界)；</li>
<li>加上为了支持 virtual 机制而由内部产生的任何额外负担(overhead)。</li>
</ul>
<blockquote>
<p>一个指针 (或是一个reference)。本质上，一个reference通常是以一个指针来实现的，而object 语法如果转换为间接手法，就需要一个指针)，不管它指向哪一种数据类型，<strong>指针本身所需的内存大小是固定的</strong>。</p>
</blockquote>
<h3 id="1-3-1-指针的类型"><a href="#1-3-1-指针的类型" class="headerlink" title="1.3.1 指针的类型"></a>1.3.1 指针的类型</h3><p>一个指向ZooAnimal 的指针是如何地与一个指向整数的指针或一个指向template Array 的指针有所不同呢 ?</p>
<p>以内存需求的观点来说，没有什么不同！它们三个都需要有足够的内存来放置一个机器地址。“指向不同类型之各指针” 间的差异， 既不在其指针表示法不同 ，也不在其内容 (代表一个地址)不同，而是在其所寻址出来的 object 类型不同。也就是说，“指针类型”会教导编译器如何解释某个特定地址中的内存内容及其大小:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ZooAnimal</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> loc;</span><br><span class="line">  String name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个指向地址 1000 的整数指针，在 32 位机器上，将涌盖地址空间1000~1003 (32位机器上的整数是4-bytes)。</li>
<li>如 果 String 是传统的 8-bytes (包括一个4-bytes 的字符指针和一个用来表示字符串长度的整数)，那么一个 ZooAnimal 指针将横跨地址空间1000~1015。</li>
</ul>
<p>那么，一个指向地址1000 而类型为<code>void*</code>的指针，将涵盖怎样的地址空间呢? 是的，我们不知道!这就是为什么一个类型为<code>void*</code>的指针只能够持有一个地址，而不能够通过它操作所指的object的缘故。<br>所以，转换 ( cast )其实是一种编译器指令。<strong>大部分情况下它并不改变一个指针所含的真正地址，它只影响 “被指出之内存的大小和其内容” 的解释方式</strong>。</p>
<h3 id="1-3-2-加上多态以后"><a href="#1-3-2-加上多态以后" class="headerlink" title="1.3.2 加上多态以后"></a>1.3.2 加上多态以后</h3><p>现在考虑一个Bear类，作为一种ZooAnimal：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Bear</span>();</span><br><span class="line">  ~<span class="built_in">Bear</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">Dances</span> &#123; ... &#125;;</span><br><span class="line">  </span><br><span class="line">  Dances dances_known;</span><br><span class="line">  <span class="type">int</span> cell_block;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Bear <span class="title">b</span><span class="params">(<span class="string">&quot;Yogi&quot;</span>)</span></span>;</span><br><span class="line">Bear *pb = &amp;b;</span><br><span class="line">Bear &amp;rb = *pb;</span><br></pre></td></tr></table></figure>

<p><code>b,pb,rb</code>会有怎样的内存需求？ 不管是<code>pointer</code>或<code>reference</code>都只需要一个word的空间。Bear object需要24bytes, 也就是 ZooAnimal 的16bytes加上Bear所带来的8bytes。其可能的内存布局如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://pic.imgdb.cn/item/66208ab20ea9cb1403bdc6fe.png"
                      alt="DerivedLayout"
                ></p>
<p>多态只能由”指针“或”引用“来实现，根本原因在于:</p>
<ul>
<li>指针和引用(通常以指针来实现)的大小是固定的(一个word)，而对象的大小却是可变的。其类的指针和引用可以指向(或引用)子类，但是基类的对象永远也只能是基类，没有变化则不可能引发多态。</li>
<li>一个point或reference绝不会引发任何”与类型有关的内存委托操作“，在指针类型转换时会受到的改变的只有它们所指向的内存的大小和解释方式而已。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>深入理解对象模型</tag>
      </tags>
  </entry>
</search>
